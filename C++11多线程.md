### C++11多线程
1. C++11中thread类，加入了标准库，多线程才开始能跨平台,一般来说进程的生命周期是和主线程一样，一个进程的主线程如果结束了，一般情况下，其他的线程也会被操作系统强行终止   
2. 创建线程  
    ```C++
        //以无参函数构建线程  
        void MyPrint(){
        std::cout << "thread1 hi!\n";
        std::cout << "thread1 bey\n";
        }        
        std::thread myObj(MyPrint);

        //以类对象构建线程
        class A{
        public:
            void operator() (){} //类中必须重载(),成为可调用对象，才能构建线程      
        }
        A a;
        std::thread myObj(a); 

        //以类的成员函数构建线程
        class A{
        public:
            void func(int &i){
                std::cout << i << std::endl;
            }    
        }
        A a;
        int i = 10;
        std::thread(&A::func, &a, ref(i));
        a.join();

        //用lambda表达式构建线程
        auto myLambdaThread = [] {
            std::cout << " hello \n";
        };
        std::thread myObj(myLambdaThread);

        myObj.join();   //主线程等待和子线程汇合
        myObj.detach(); //子线程和主线程脱离关系  
    ```  
3. join()函数和detach()  
    * join()阻塞直到线程结束，用来保证主线程在子线程结束之后结束,实现主线程和子线程汇合
    * detach(),分离，主线程不与子线程汇合了，主线程不用等待子线程结束之后再结束，一旦detach之后，，thread对象就会和主线程失去联系，该子线程就被系统接管，子线程执行完之后，由系统负责清理相关的资源，使用detach时，如果传递的参数中有引用，可能会有主线程先结束，引用的变量被销毁了的情况，子线程中引用该变量就会出现问题     
    * joinable(),用来判断能不能使用join()和detach()函数     

4. 数据共享问题  
    * 只读数据共享是线程安全的，不需要特殊的机制保证线程安全  
    * 有读有锁的时候如果不做特殊处理就会导致程序崩溃  

5. 解决线程安全问题  
    * mutex(互斥量):其实就是一个类对象。可以理解成一把锁，加锁的代码要合适，少了达不到效果，多了影响效率  
    ```C++
    //lock(),unlock()要成对的使用  一一对应  
    std::mutex my_mutex;
    my_mutex.lock();    //加锁
    //....
    my_mutex.unlock();  //解锁

    //为了防止忘记unlock，引入了std::lock_guard(),lock_guard()是一个类模板，会自动的解锁，用来替代lock和unlock,通过RALL机制封装的，在构造的时候lock，析构的时候unlock
    std::lock_guard<std::mutex> my_lock(my_mutex);  
    //lock_guard只有在析构的时候才能解锁，不能随时解锁，这样如果需要加锁的代码后面有许多不需要加锁的代码时，就会导致加锁的时间太长，可以通过添加代码段的方式实现解锁
    {
        std::lock_guard<std::mutex> my_lock(my_mutex);
        //...

        //代码段结束之前就会析构解锁  
    }

    //多个mutex，会产生死锁问题，为了解决死锁问题,引入了lock函数  
    std::lock(a.Mutex, b.Mutex /*.....*/)   // 这个标准的函数可以传入任意个锁，然后会按着一定的顺序是上锁，保证每一个调用的地方都是按着这个顺序上锁，但是不会主动解锁 
    /* 猜测一下实现，首先是去重，然后是排序，最后按排好的顺序加锁 */
    //因为不会主动解锁，所以需要和std::lock_guard、std::adopt_lock配合使用，实现解锁操作  
    std::lock_guard<std::mutex> lockA(a.Mutex, std::adopt_lock);    //std::adopt_lock告诉构造函数，a.Mutex我已经锁上了，不用在构造函数中加锁了，只要在析构函数中解锁就行了
    std::lock_guard<std::mutex> lockB(b.Mutex, std::adopt_lock);    //释放锁  
    ```   
    