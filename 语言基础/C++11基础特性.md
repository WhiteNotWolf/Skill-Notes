1. long long 类型。
    c++11规定的新类型。c++标准规定，int至少和一个short一样大，long long至少和一个long一样大，即32位。 long long一般是64位，具体实现与机器相关。

2. 列表初始化。
    新标准中增加了列表初始化，即使用花括号来初始化。无论是初始化或者为对象赋新值，都可以采用这种形式。
    如  vector<int> a{1,2,3,4};  
    初始化时，()与{}含义是不一样的。如vector<int> a(10);定义了一个长度为10的vector，其值由vector定义。vector<int> a{10};定义了一个长度为1的vector，其元素值为10；vector<int> a(10,1);定义了含有10个1的vector。此外还可以使用vector<int> a = {1,2,3}形式，使用列表赋值会用右边的元素替换左边的元素。
    如果变量定义时没有指定初始值，则变量会被默认初始化，此时变量被赋予了默认值，默认值到底是什么由变量的类型和变量定义的位置确定。
    如果内置类型没有被显示的初始化，则定义与任何函数之外的变量被初始化为0，定义在函数体的变量将不被初始化(类的数据成员也是)，没有初始化的内置类型的值是未定义的。类的对象具体行为由类自己定义。大部分类允许无须显式初始化定义对象，此时，对象的初始值由类自己定义，如string对象无须初始化，其初始值为一个空串。

3. 空指针nullptr。
    新标准中加入了特殊的字面值nullptr，它可以被转化成任意其他的指针类型。在新标准下，c+       +程序应该尽量使用Nullptr，同时避免使用null。因为在c++程序中，赋值空指针应该是0，NULL在预处理时，宏      替换为0(#define NULL 0)，来给指针赋值，但是NULL是无类型的(在c语言环境下，由于没有重载，所以可以义      #define NULL  (void*)(0)来给NULL定义类型，但C++不行,在C++中直接给某类型指针赋一个void指针是非法   的，因此c++程序中 NULL单纯表示0。)，但是nullptr是有类型的。
    假如有函数 void fun(void* ), void fun(int ).使用fun(NULL)时会调用int版本，但是nullptr能保证在任何情况下都表示一个空指针,即一定会调用void*版本。

4. constexpr常量表达式。
    在复杂系统中，很难分辨一个初始值是不是常量表达式，C++标准规定，允许将变量声明为constexpr类型，以便由编译器来验证变量是否是一个常量表达式。声明为costexpr的变量一定是一个常量，而且必须用常量表达式初始化。一般来说，如果认为某变量是一个常量表达式，应该将其声明为constexpr类型。
    例如：C++编译时可确定常量表达式的结果，因此可在编译时优化。C++规范在一些地方要求使用常量表达式，如声明数组的维数。但常量表达式不允许包含函数调用或者对象构造。因此下述代码无效：
    int get_five() {return 5;}
    int some_value[get_five() + 7];
    但是将上述函数定义为constexpr int get_five() {return 5;}。则可以满足。
    C++11跟C++14的对constexpr的限制要求不太一样，具体没必要了解太深。

5. 类型别名声明
    传统的方法是使用typedef，新标准可以使用using语句，如using MyInt = int ;
    注意使用类型别名时，如果是复合类型，在声明时将别名替换为原来的类型去理解类型是错误的。
    例如 using str = string*; const str a;与const string* a;是不一样的。

6. 类型指示符auto
    编程时，常常把表达式的值赋给变量，这就需要清楚的知道表达式的值的类型，新标准中引入了auto类型说明符，可以由编译器自己去推断表达式的类型。auto让编译器通过初始值来推断类型，因此使用auto说明符的变量必须要有初始值。auto可以作为函数的返回值类型，此时函数内部所有返回值应该属于同一个类型。auto不能作为函数形参类型。

7. decltype类型说明符
    decltype返回的是其参数的类型。例如decltype(a) b，定义了一个与a同类型的变量b。decltype作用于引用类型时，返回的是一个引用类型。作用于解引用时，返回的也是一个引用类型（一般来说可以通过解引用改变引用对象的值，因此这里应该是引用类型而不是非引用类型）。

8. 类内初始化
    新标准规定，可以为数据成员一个类内初始值。创建对象时，类内初始值用于初始化数据成员，没有初始值的将被默认初始化。定义在类内和函数内的变量将不被初始化(2.列表初始化)。当我们提供类内初始值时，必须使用=或者花括号表示。

9. 范围for语句
    vector<int> a;
    for(auto i : a)此时i的类型是int,a表示的必须是一个序列，一般情况下拥有返回迭代器的begin和end成员。注意如果需要改变a中的元素，应该将i声明为引用类型。

10. 关于容器迭代定义。
    如vector<vector<int>>早期版本需要在外层右尖括号之前打一个空格：vector<vector<int> >。现在取消了这个限制，但是有的编译器可能还是不行。

11. begin与end
    为了兼容数组,使泛型算法可以作用于数组，C++添加了标准库的begin函数，在容器中，begin是成员函数，返回一个迭代器。对于标准库begin函数，应该使用数组作为参数，如int a[5], auto b = begin(a);,返回一个指向数组首元素的非常指针,cbegin(a)返回一个指向首元素的常指针。可以使用这种形式调用泛型算法： i = count(begin(a),end(a),value)。
    关于数组指针与引用的定义：引用不是对象，因此不存在引用的数组，但是有数组的引用，例如 int (&a)[10]；定义了一个a,引用长度为10的数组的对象。同理, int (*a)[10]定义了一个指针a指向长度为10的数组。

12. 关于除法的问题。
    在除法运算中，如果两个数符号相等，则商为正，否则为负。C++11新标准规定商一律向0取整。(-m)/n与m/(-n)都等于-(m/n)。m%(-n)等于m%n，(-m)%n等于-(m%n)。

13. initializer_list形参。
    如果函数的实参数量未知，但是全部实参的类型都相同。则可以使用initializer_list类型的形参。initializer_list表示某种特定类型的值的数组。initializer_list也是一个模板，使用时必须提供模板参数。
    如void test(initializer_list<int> ls);在使用时，实参需要用花括号括起来。如test({1,2,3,4});
    initializer_list也有size,begin,end成员函数，用来遍历元素。
    （一般用在与C程序的接口）

14. 列表初始化返回值。
    C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。比如所，返回vector<string>的函数可以这样返回： return {"hello", "world"}。

15. 尾置返回类型。
    使用尾置返回类型时吗，在本应该写返回类型的地方用auto替代。然后在函数参数列表之后加上->表示尾置返回。
    例如auto test(vector<int> i) -> decltype(i)。
    因为在有些时候，特别是模板编程中，返回类型依赖参数类型，这种时候尾置返回类型就很有用了。

16. =default生成默认构造函数
    新标准中，如果我们需要默认的行为，可以通过在参数列表后面加上=default来要求编译器生成构造函数，=default可以出现在类内部，也可以在外部定义。出现在内部则默认是内联的，外部默认是不内联的。

17. 非成员函数swap
    标准库swap函数可以在常数时间内交换两个容器内容，元素本身并不交换，只交换了内部数据结构。
    新标准中swap函数是通过右值引用来实现的。

18. 容器insert函数和emplace函数。
    insert函数将元素插入到给定的迭代器之前。并返回一个指向第一个插入元素的迭代器。
    emplace_front,emplace,emplace_back分别对应push_front,insert,push_back函数，区别在于，push函数传递一个对象，将其拷贝到指定位置，而emplace函数接受一个参数列表，并在指定位置调用对象的构造函数，构造一个对象。

19. 容器内存分配函数
    c.capacity():不重新分配空间的话，c可以保存多少元素。
    c.reserve(n)： 分配至少能容纳n个元素的空间。
    c.shrink_to_fit():将capacity减少为和size()相同大小。
    只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量，如果需求大于当前容量，reserve分配至少和需求一样大的空间(或者更大)。如果需求小于当前容量，则reserve什么也不做。
    shrink_to_fit函数具体实现可以忽略请求，也就是说可能调用了该函数但是什么也没有做。

20. string转换函数。
    to_string(val),将val转换为string形式，返回该string对象。
    stoi,stod,stol等函数，将string转换为对应格式的数值类型。stoi(string("4396))返回一个4396的int对象。

21. lambda表达式。
    对于一个对象或者表达式，如果可以使用调用运算符(),则称其为可调用的。lamnda表达式可以理解为未命名的内联函数。形式[capture list](parameter list) -> return type { function body }。其中capture list为捕获列表，为lanmda表达式所在函数中定义的局部变量的列表(通常为空)。参数列表和返回类型有时候可以忽略，但必须有捕获列表和函数体。lanmda表达式必须使用尾置返回类型，且lanmda表达式不能有默认参数。被捕获的变量，如果是值捕获，则在创建lanmda时拷贝该值，而不是调用时拷贝。如果要捕获引用，比如某些不允许拷贝的对象，只需要在捕获的对象名前加引用符&。需要注意的是，应该确保引用的对象，在lanmda调用时对象时对象是存在的。出于同样的原因，如果需要函数返回一个lanmda表达式，该lanmda表达式不能含有引用捕获。
    