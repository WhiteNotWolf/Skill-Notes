31. 删除的拷贝控制和继承
    就像其他的任何类，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义为删除的。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数。
    如果基类的默认构造函数，拷贝构造函数，拷贝赋值运算符或者析构函数是删除的或者不可访问的，则派生类对应成员是删除的，因为编译器不能使用基类成员来执行派生类对象的基类部分的构造、赋值或者销毁操作。
    如果基类有一个删除的或不可访问的析构函数，则派生类中合成的默认构造函数和拷贝构造函数将是删除的，因为编译器不能销毁派生类对象的基类部分。
    编译器不会合成一个删除掉的移动操作，如果使用=defalut请求一个移动操作时，如果基类的对应操作时删除的或不可访问的，则派生类该函数是删除的，因为派生类对象的基类部分不可移动。同样的，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也是删除的。
    总之，如果需要相应操作的话，最好自己显示定义，需要默认操作时可以使用=default，不需要某操作时，也需要显示使用=delete。不要让编译器干你不知道的事。

32. C++继承构造函数
    C++派生类不会继承默认构造函数，拷贝构造函数，拷贝赋值运算符。但是我们可以通过using语句来“继承”，比如在A的子类B中，可以使用using A::A;来显示继承A的构造函数。（没整明白为什么需要这个特性）

33. 声明模板类型为友元，模板类型别名
    我们可以声明模板的类型参数为友元，如
    temolate<class T> class A{
        friend T;
    };
    例如我们使用某个类来初始化模板时，该来为模板类的友元，但是模板类型参数可能是内置类型，在新标准中，内置类型的友好关系是允许的。
    可以使用using或者typedef来定义模板类型别名。如using StrA = A<string>;

34. 模板默认实参
    新标准中允许为模板函数提供默认实参，如template <class T = string> compare(T& a, t& b);类模板也可以。而且，以前的标准是只允许类模板提供模板实参，函数模板不行。

35. 标准库forward函数
    有时候在参数传递时，我们需要保持实参的类型，新标准中我们可以使用forward函数来完成这一功能。forward定义在头文件utility中，与move不同，forward必须通过显示模板实参来调用，forward返回该显示实参类型的右值引用。即forward<T>的返回类型是T&&，通常情况下我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过引用折叠，forward可以保持给定实参的左值或者右值属性。（因为在函数中，即使参数是一个右值，但是无论在什么时候，变量名永远是一个右值，此时将该变量名作为参数时，实际上是传递了一个左值，因此需要使用forward）比如以下函数：
    template <class T> test(T&& arg)
    {
        call(forward<T>(arg));
        虽然arg是一个右值引用，但在此时arg是一个左值，因为它是一个变量名，但是通过forward可以保证他原有的属性，使用一个右值来调用call。即使arg是一个左值，那么forward也能保持arg的属性不变，例如arg是int类型的左值，此时T推断出的类型是int&，则T& &&仍然是一个左值。
    }

36. 可变参数模板
    可变参数模板是指一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为参数包，即存在模板参数包和函数参数包。定义可变参数的方式是使用省略号...。指出一个模板参数或函数参数表示一个包。例如：
    template<class T,class... args>
    void foo(const T&, const args... rest)
    其中args表示模板参数包，rest则是一个函数参数包。与普通模板一样，编译器通过实参来推断参数包类型，例如foo(5,1.0f,3.14f);则T推断出为int类型，参数包类型为<float,float>，函数参数包为(1.0f, 3.14f)。
    如果我们需要知道包中含有多少个元素，可以使用sizeof...运算符，例如sizeof...(rest)或者sizeof...(Args)，返回一个表示数目的常量表达式。

    可变参数模板函数通常是递归的，因为就算模板参数为空，编译器也可以认为这是一个空的模板参数包，例如上面的代码。例如：
    template<class T>
    ostream& print(ostream& os,const T& t)
    {
        return os<<t;
    }
    template<class T,class... Args>
    ostream& print(ostream& os,const T& t,const Args&... rest)
    {
        os << t << ' ';
        return print(os,rest...);
    }
    第一个版本的print负责种植递归打印初始调用的最后一个实参，如果没有上述版本的话，则当最后print函数只有两个参数的时候，其中一个为ostream，一个用来初始化T,此时编译器会认为该函数包为空函数包，则调用print(os,rest)时，此时rest为空，则调用失败，因为没有能用来拿来初始化T的参数了。
    包扩展，通过在参数包后面加上...来扩展参数包，如上面的rest...就是扩展参数包，也就是将参数包扩展为多个参数，此时扩展规则为默认规则，如果是string(rest)...则按照转换为string的规则扩展该参数包。在参数中的Args& ... rest为按引用方式扩展Args，为print生成参数列表。
    我们可以配合标准库forward函数来实现参数转发。即在可变参数模板函数中调用函数。

37. tuple类型
    tuple类型是类似pair的一种类型，不同的是pair类型有且只有两个成员，而tuple可以有任意数量的成员。
    在希望将一些数据组合起来，但又不想定义数据结构时，就可以用到tuple了，定义在头文件tuple中。
    tuple<T1, T2, T3,...,Tn> t;定义一个tuple类型的对象t，其成员数为n，t的第i个成员类型为Ti。且所有成员执行值初始化。
    tuple<T1, T2, T3,...,Tn> t(v1,v2,v3,...,vn);此构造函数是明确的，即explicit的。
    标准库提供了make_tuple(v1,v2,...,vn)来返回一个tuple，tuple的类型由编译器推断。
    get<i>(t)返回tuple对象t的第i个成员的引用。
    tuple_size<t>::value，该模板使用tuple类型初始化，value表示tuple类型t的成员数量。
    tuple_element<i,T>::type，value表示tuple类型T的第i个成员的类型。

38. 标准库bitset类型
    标准库提供了bitset类型来使位运算更容易。
    bitset<n> a;定义了有n位的bitset每一位都是0.
    bitset<n> a(u);a是unsigned long long 值u的低n位的拷贝。如果n大于unsigned long long的大小，则超出部分置为0.此构造函数是constexptr的。
    bitset<n> a(s, pos, m, zero, one)a是string对象s从位置pos开始的m个字符的拷贝，s智能包含字符zero或者one；如果含有其他任意字符，则抛出异常。字符在a中分别保存为zero和one，pos有默认值为0，m默认值为string::npos，npos表示不存在的位置，一般定义为unsigned npos = -1，可以理解为string的长度。zero默认为0，one默认为1。该构造函数也是explicit的。
    bitset<n> a(cp,pos,m,zero,one)与上面的构造函数基本相同，不同的是cp代表的是一个C风格的字符串。
    string中的下标刚好与bitset相反，string中下标最大的字符用来初始化bitset的最低位。如bitset<5> b("1100")；则b[0]为string的最高位即0.b为00110.
    b.any()，b中是否有被置位的位，被置为代表1.有1则返回true。
    b.all()，b中是否全被置位，若全为1则返回true。
    b.none(),b中是否全为0，如全为0则返回true。
    b.count()，返回b中被置位的位数。
    b.size()，返回b中的位数。即初始化模板时提供的n。
    b.test(pos)，位置pos是否是置位的，是1则返回true。
    b.set(),b.set(pos,v)，将pos位置置为v，v默认为true，如不提供参数，将b中所有位置位。
    b.reset(pos),b.reset()，将pos位置复位（0），如果不提供参数，则将所有位复位。
    b.flip(pos),b.flip()，将pos位置取反，不提供参数的话，对b所有位取反。
    b[pos]，返回位置pos的引用，如果是const的，则返回true或者false。
    b.to_ulong(),b.to_ullong(),b.to_string(zero,one)，将bitset转换为ulong或者ulong long 或者string。其中string的zero默认为0，one默认为1.
    bitset还重载了流输出和输入符，os << b，将b中二进制位打印为字符1或者0，打印到流os中。
    is >> b。从is中读取字符到b，当下一个字符不为0或1时，或者已经读取b.size()时，读取停止。

39. 正则表达式
    正则表达式描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串，将匹配的子串替换或者从某个串中取出符号某个条件的子串。C++使用的是ECMAScript标准的正则表达式。
    普通字符：包括没有显式指定为元字符的所有可打印字符和不可打印字符，包括所有大写和小写字母，所有数字，所有标点符号和一些其他符号
    元字符：
    非打印字符也可以是正则表达式的组成部分。
    需要注意的是，在C++中'\'也是一个特殊字符，因此想要得到与ECMAScript相同的效果，需要使用\\。
    \cx匹配由x指明的控制字符，如\cM匹配一个control-M。x必须是A-z的范围，否则c视为原义的'c'字符。
    \d匹配一个数字字符。
    \D匹配一个非数字字符。
    \w匹配字母、数字、下划线。
    \W匹配非字母、数字、下划线。
    \f匹配一个换页符。
    \n匹配一个换行符。
    \r匹配一个回车符。
    \t匹配一个制表符。
    \v匹配一个垂直制表符。
    \s匹配任何空白字符，包括空格制表符换页符等等，等价[ \f\n\r\t\v]。
    \S匹配任何非空白字符，等价于[^ \f\n\r\t\v]。
    \xn匹配n，其中n为十六进制转义值，十六进制转义值必须为确定的两个数字常。例如\x41，匹配'A'。正则表达式可以使用ASCII编码。
    \un匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。
    非捕获元?:,我们可以使用圆括号括起来一些字符形成一个子表达式，但是会有一个副作用，这个子表达式的匹配结果会被缓存。此时可以使用?:放在第一个选项来显示要求不用缓存。
    \num用来显示指明表达式匹配的缓存,即向后引用，缓存最多可以存储99个，下标从0开始。如匹配连续的三个重复数字(\\d)\\1{2}。\\d用来匹配数字，此时\\1表示该匹配的结果,子表达式的序号为其左括号出现的次序，第一个子表达式就是整个表达式本身，因此\\1才是表示此表达式的结果而不是\\0，{2}表示该结果又出现了两次。不要在[]内使用向后引用。

    特殊字符：
    $，匹配输入字符串的结尾位置，
    ()，标记一个子表达式的开始和结束位置，
    *，匹配前面的子表达式零次或多次。
    +，匹配前面的子表达式一次或多次。
    ？，匹配前面的表达式零次或一次。
    .，匹配除换行符之外的任何单字符。[^\n\r]
    [，标记一个中括号表达式的开始。
    \，将下一个字符标记为特殊字符或原义字符。如\n匹配换行，\(匹配'('
    ^,匹配输入字符串的开始位置，在方括号中使用时，它表示非。
    {，标记限定符表达式的开始。
    |，指明两项之间的选择。

    限定符：
    限定符除了+*?之外还有以下三种：
    {n}，n为非负整数，匹配确定的n次。
    {n,}n为非负整数，匹配至少n次。
    {n,m}n，m都为非负整数，且n<=m，匹配至少n次，至多m次。

    定位符：
    ^和$都是定位符，除此之外，还有两种定位符。
    \b，匹配一个单词边界。单词边界即单词和空格之间的位置。非单词边界是其他任何位置。
    \B,匹配一个非单词边界。

    限定符+和*都是贪婪的，即他们为尽可能的匹配更多的字符。如果需要非贪婪，则可以在后面加上?来实现最小匹配。
    比如<a>c++ is the best language.<\a>如果使用\<.*\>，则会匹配整个字符串。而\<.*?\>只匹配标签<a>和<\a>。

    优先级：
    最高： 转义符\
    较高： (),(?:),(?=),[]
    其次： *,+,?,{n},{n,},{n,m}
    最低: ^,$,\任何元字符，任何字符

40. C++正则表达式库regex
    regex初始化，可以直接使用string类型初始化regex对象，如string pattern("[\d]+"),regex reg(pattern)
    ，还可以用C风格数组的指针初始化，也可以使用迭代器表示字符范围，或者字符指针和表示长度的n，此外regex也可以直接赋值。另外，r.mark_count()，返回r中子表达式的数目。r.flags(),返回r的标志集。
    regex_match函数，将一个字符序列与一个正则表达式匹配。
    regex_search函数，寻找第一个与正则表达式匹配的子序列。
    smatch容器类，用来保存在string中搜索的结果。
    ssub_match用来表示string中匹配的子表达式的结果。
    函数regex_match和函数regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个表达式匹配，则regex_match返回true，如果某个子串匹配，则regex_search返回true。这些函数还定义了重载的版本，
    (seq,m,r,mft)与(seq,r,mft)其中seq表示字符序列，r表示regex对象，m是一个match对象，用来保存匹配结果的相关细节，mft是一个可选的参数值，会影响匹配过程，一般情况下使用默认参数就可以了。

    指定regex对象的选项
    使用方法为构造regex对象时指定参数，regex r(re,f)，re为用来初始化regex对象的string或者字符串，f默认为ECMAScript参数，表示使用ECMA-262指定的语法。其他几种常用的参数：
    icase 匹配过程中忽略大小写。
    nosubs 不保存匹配的子表达式
    optimize 执行速度优于构造速度
    例如regex reg(pattern.begin(),pattern.end(),regex::icase);
    还有几种参数用于改变正则表达式的语法.

    正则表达式可以理解为一门新的语言，实际上，正则表达式是在运行时而非编译时编译的，因此正则表达式的错误可能在编译时才抛出。而且正则表达式的编译时一个非常慢的操作，程序开发时应该要注意避免不必要的开销。
    另外，输入序列类型不同时也需要使用不同的正则类，如在搜索string序列时，使用regex,smatch,ssub_match,sregex_iterator。但在搜索序列为char类型字符串时，对应的类就是，regex,cmatch,csub_match,cregex_iterator。

    regex迭代器
    regex迭代器是一种迭代器适配器，它被绑定到一个输入序列和一个regex对象。
    sregex_iterator it(b,e,r)。遍历迭代器b和e表示的string。调用sregex_search(b,e,r)将it定位到输入中的第一个匹配的位置。
    sregex_iterator end;类似于尾后迭代器，一般用来做终止循环的判断条件。
    除此之外，regex迭代器还支持其他迭代器都支持的操作，如自增操作符，解引用操作符，成员访问操作符。

    smatch操作
    m.ready() 如果已经通过regex_search或者regex_match设置了m，则返回true。
    m.size() 如果匹配失败，返回0，否则返回最近一次匹配的正则表达式中子表达式数目。
    m.empty() 如果size为0，返货true。
    m.prefix() 返回一个ssub_match对象，表示当前匹配之前的序列。
    m.suffix() 返回一个ssub_mtach对象，表示当前匹配之后的部分。
    m.length(n) 第n个匹配的子表达式的大小。
    m.position(n) 第n个子表达式距序列开始的距离。
    m.str(n) 第n个子表达式匹配的string。n默认值为0，也就是整个表达式的结果。
    m[n] 对应第n个子表达式的ssub_match对象。
    m.begin(),m.end() 表示m中sub_match对象的范围的迭代器。
    比如说string str("aabbcc")和regex对象regex reg("([A-z])\\1{1}")该regex对象匹配任意两个重复的字母。当使用regex_iterator迭代器遍历时，可以得到结果aa,bb,cc。其中子表达式有两个，第一个是正则表达式本身，第二个是[A-z],因此size函数返回值为2.对于第一个子表达式也就是正则表达式本身，prefix()函数返回指向空串的ssub_match对象，而suffix()函数返回指向bbcc的ssub_match对象。如果需要访问其他匹配结果，如除了aa之外匹配的字符串，则通过迭代器regex_iterator访问成员函数。否则smatch只能访问第一次匹配成功的字符串。

    使用子表达式
    一个子表达式是模式的一部分，其本身也具有意义。
    但是存在某种情况，即子表达式()之后接一个?，表示该子表达式是可选的，也就是存在整个表达式匹配但是该子表达式无匹配的情况，为了不影响其他子表达式，无论子表达式是否匹配都不影响其在match中的下标。我们可以通过matched数据成员来检查该子表达式是否匹配了,该成员是public bool类型，表示该子表达式是否匹配到了对应串。例如
    string str("aa1bcc");
    regex reg(string("([A-z])\\1{1}([0-9])?"));
    sregex_iterator it(str.begin(),str.end(),reg),it_end;
    while(it != it_end)
    {
        if((*it)[2].matched){
            cout << it->str() << endl;
            cout << (*it)[2].str() << endl;
        }
        else{
            cout << it->str() << endl;
            cout << "none" << endl;
        }
        it++;
    }
    该程序输出aa1,1,cc,none。
    除此之外，子表达式还提供了一些其他成员：
    first,second。public成员，指向匹配序列的首元素迭代器和尾后迭代器。
    length()，匹配序列的大小。如果matched为false，则返回0.
    str(), 返回一个包含输入中匹配部分的string,如果matched为false，则返回空字符串。
    s = ssub 将ssub_match对象ssub转化为string对象，该转换不是explicit的。即可以在需要使用string的地方使用ssub_match对象代替。该转换会隐世进行。

    regex_replace函数。

    正则表达式不仅用在需要查找给定序列的时候，当我们需要将特定序列转换为另一个序列的时候，正则表达式也是有用的。
    regex_replace()函数类似搜搜函数，它接受一个输入字符序列和一个regex对象，不同的是他还接受一个藐视我们想要的输出形式的字符串。

    m.format(dest,fmt,mft) 与m.format(fmt,mft),使用格式字符串fmt生成格式化输出，mft为可选的标志。第一个版本写入迭代器dest指向的目的位置并接受fmt参数（格式化字符串），可以是一个string，也可以是指向C风格字符串的指针。第二个版本返回一个string，保存输出，并接受fmt参数。mft的默认值是format_default。该函数将匹配结果match对象根据格式化输出字符串转换为特定字符串，输入到指定位置或返回string对象。

    regex_replace(dest,seq,r,fmt,mft)或regex_replace(seq,r,fmt,mft)。mft为可选参数，默认值为match_default。r为regex对象。第一个版本将输出写入到迭代器dest指定的位置，并接受一对迭代器seq表示输入序列的范围，第二个版本返回一个string，保存输出，seq既可以是一个string也可以是一个指向C风格字符串的指针。在所有情况下，fmt既可以是一个string也可以是一个指向C风格字符串的指针。该函数使用regex对象匹配指定字符串，并根据格式化输出字符串，转换到特定字符串，输入到特定位置或者返回string对象。

    例如string fmt("$1.$2.$3");regex reg("([0-9])([0-9])([0-9])");string str("123")
    调用函数regex_replace(str,reg,fmt)，fmt中的$1表示子表达式1的匹配结果，此时该函数会返回string(1.2.3).默认情况下，regex_replace函数输出整个输入序列，未与正则表达式匹配的部分会原样输出。匹配的部分按格式字符串指定格式输出。如果需要不输出不匹配部分的话，可以令mft参数值为format_no_copy。

    关于格式化字符串：$n 表示第n个子表达式匹配的结果， $&表示整个匹配结果， $`表示prefix， $$表示$字符本身。

41. 随机数库
    新标准之前，C/C++都以来一个C函数rand来生成随机数，此函数生成均匀分布的伪随机函数，每个随机数的范围在0和一个系统相关的最大值之间。但是rand函数有一些问题：某些程序需要使用不同范围的随机数。一些应用需要随机浮点数，一些程序需要非均匀分布的数，而在使用rand函数向这种需求转换时，程序员很有可能会引入非随机性。
    定义在头文件random中的随机数库通过一组协作的累来解决这些问题，随机数引擎类和随机数分布类。一个引擎类可以生成unsigned随机数序列，一个分不累使用一个引擎类生成指定类型的服从特定分布随机数。
    例如：default_random_engine e; cout << e() << endl;会生成一个随机数，范围就是unsigned所能表示的范围，但是，在每次运行程序时，都会输出相同的结果。（为了方便调试）,一个给定的随机数发生器(分布对象+引擎对象)会一直生成相同的随机数序列，一个函数如果定义了局部的随机数发生器，应该将其定义为static的。否则每次都会产生相同的序列。
    随机数支持的操作:
    Engine e;使用默认构造函数，即使用该引擎默认的种子初始化该引擎。
    Engine e(s);使用整型值s作为种子初始化种子。
    e.seed(s)； 使用种子s重置引擎的状态。
    e.min(),e.max()，此引擎可生成的最小值和最大值。
    e.discard(u)，将引擎向前推进n步，u的类型为u long long。
    e()；重载的调用运算符，返回下一个生成的随机数。
    关于种子：引擎通过种子，来从生成的随机数序列的一个新位置重新开始生成随机数，来达到不重复的目的。

    均匀分布的分布类型： uniform_int_distribution<intT> u(m,n)其中可以使用整型来代替intT，
    浮点类型uniform_real_distrubution<realT> u(x,y)其中可以使用float,double等代替realT。其中m,n和x,y分别表示生成的值的取值范围。例如:
    default_random_engine e;
    uniform_real_distribution<float> u(0,1);
    while(true){
        cout << u(e) << endl;
        this_thread::sleep_for(1s);
    }

42. IO库
    IO条件状态，IO操作一个与生俱来的问题就是，它可能会发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，超出了可修正的范围，标准库提供了IO类的一些函数和标志，用来访问流的条件状态：
    strm::iostate strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能。流提供了几个iostate类型的数据成员用来表示流状态。以下几个都是静态常量成员。
    strm::badbit 用来指出流已经崩溃
    strm::failbit 用来指出一个IO操作失败了
    strm::eofbit 用来指出流到达了文件结束
    strm::goodbit 用来指出流未处于错误状态。

    标准库还提供了函数来访问或操作标志位：
    s.eof() 若流到达文件末尾，返回true。
    s.fail() 如果流操作失败或已经崩溃，返回true。
    s.good() 若s处于有效状态，返回true.
    s.clear() 将s中所有条件状态复位，流状态设置为有效。
    s.clear(flags) 根据给定的flags标志位，将流s中对应条件状态位复位。flags的类型为strm::iostate
    s.setstate(flags) 根据给定的flags标志位，将流s中对应条件状态位置位。flags的类型为strm::iostate
    s.rdstate() 返回s的当前条件状态，类型为strm::iostate。

    我们可以通过这些函数记住一个流的初始状态，将其置位有效，使用之后再还原：
    auto old_state = cin.rdstate()
    cin.clear()
    //use cin//
    cin.setstate(old_state)

    在输入时，我们可以使用eof标志来判断文件是否输入完成, 如：
    ifstream is("test");
    while(!is.eof()){
        //操作is。
    }或者可以使用 !(is.rdstate() & is.eofbit)来判断，即通过rdstate函数得到当前状态，再通过与操作判断eof位是否被置位。

    一般来说，badbit表示系统级错误，通常情况下badbit被置位，流就无法再使用了，也就是这个流无法修复了。failbit表示可恢复错误，如流输入格式不匹配等等，此时流还是可以继续使用的。如果达到文件的结束位置，流的eofbit和failbit都会被置位。goodbit的值为0，表示流未发生错误。如果除了goodbit的任意一个被置位，则检测流状态的条件会失败。

    关于流的刷新机制：
    每个输出流都管理一个缓冲区，用来保存程序读写的数据。文本串可能被立即打印出来，也可能被操作系统保存在缓冲区，随后再打印。由于设备的写操作可能很耗时，因此允许操作系统将多个输出操作组合成单一的系统级写操作，可以带来很大的性能提升。
    导致缓冲刷新（即数据真正写到输出设备或文件）的原因有很多：
    程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
    缓冲区满时，会自动刷新缓冲区，而后新的数据才能写入缓冲区。
    可以使用操作符endl显示刷新缓冲区。
    在每个输出操作符之后，可以使用操作符unitbuf设置流的内部状态。来清空缓冲区。例如:cout << unitbuf;所有输出操作之后都会立即刷新缓冲区。
    一个输出流可能是关联到另外一个流的，如cerr和cin是关联到cout的。因此，在cin或者cerr前都会刷新cout缓存。
    
    如果程序崩溃，输出缓冲区不会被刷新。当一个程序崩溃后，它所输出的数据可能停留在输出缓冲区中等待打印。因此可能有些你认为已经输出的数据，其实没有被输出。它们还在数据缓冲区中。而因为数据没有输出，可能会导致浪费大量时间研究一些代码为什么没有被执行上，实际上它执行了，只是缓冲区没有输出出来而已。因此使用cout等输出程序信息时，应该使用endl操作符，或者使用unitbuf来设置流的状态。

    关于文件流的打开模式：
    fstream(file,mode)；可以指定mode的方式关联文件流。
    in 以读方式打开，ifstream默认打开方式，且只能对ifstream和fstream设置in模式。
    out 以写方式打开，ofstream默认打开方式，且只能对ofstream和fstream设置out模式。
    app 每次写操作前都定位都文件末尾
    ate 打开文件后立即定位到文件末尾
    trunc 截断文件
    binary 以二进制方式进行io
    只有当out模式被设定时，才能设定trunc模式。且默认情况下，以out模式打开的文件流会被截断。
    如果trunc没被设定，则可以设定app模式。在app模式下即使没有显示的指定out模式，文件也总是以输出方式被打开。
    也就是说ofstream os(file)和ofstream os(file，fstream::out)和ofstream os(file,fstream::out | fstream::trunc)是等价的。这种模式打开文件流不会保存文件中已存在的数据。如果想要保存，需要指定app模式：
    ofstream os(file,fstream::app)等价与ofstream(file,fstream::out | fstream::app).
    ate和binary模式使用任何文件流，且可以和其他模式组合使用。

    格式化输入与输出：
    控制输出bool值的格式： boolalpha操作符。
    例如cout << true << flase << boolapha << true << flase << endl;这段代码输出1 0 true flase。
    取消操作符带来的影响的方法是，使用操作符前加no的操作符。例如cout << noboolalpha;（部分适用）

    指定整型值的进制：
    hex 十六进制
    oct 八进制
    dec 十进制
    但是某些情况下，十进制如其他进制可能没有什么区别，这时候可以使用showbase操作符，它会在输出结果中显示进制。
    cout << showbase << hex << 20 << endl;
    cout << oct << 20 << endl;
    cout << dec << 20 << noshowbase << endl;输出结果为0x14 024 20。

    控制浮点数格式：
    浮点数一般考虑三种格式：以多高精度输出，是打印十进制还是科学计数法，对没有小数部分的浮点值是否打印小数点。
    默认情况下，浮点值按六位数字打印（未打印的部分四舍五入而非截断）；如果没有小数部分，则不打印小数点。非常大或非常小的值标准库会采用科学计数法，其他采用定点十进制。
    stream.precision()返回当前精度值，如果接受参数n，stream.percision(int n)则会令当前精度为n。
    showpoint操作符，对浮点值总是显示小数点。
    scientific操作符 浮点值采用科学技术法输出。
    fixed操作符 浮点值使用定点十进制输出。
    defaultfloat操作符 浮点数使用默认格式输出。

    输出空白：
    setw()函数控制输出的位数:同时可以指定left操作符或者right操作符，来指定是左对齐还是右对齐，默认情况下是右对齐。
    setfill()允许提供一个字符替换默认的空格。setw()只对下一个输出有效。internal可以切换符号的对齐位置，默认是右对齐值。

    其他操作符：
    showpos 非负数显示+
    skipws 输入运算符跳过空白字符，默认情况下，输入是跳过空白字符的，如空格回车等，使用noskipws可以使输入运算符不跳过空白字符。
    flsuh 刷新ostream缓冲区

43. 未格式化的输入输出操作
    一般来说，输入和输出运算符根据读取或写入的数据来格式化IO操作。标准库还提供了一组底层操作，支持未格式化IO。这些操作允许我们将一个流当做一个无解释的字节序列处理。
    单字节底层IO操作：
    is.get(ch) 从istream is中读取下一个字节存入字符ch中。返回is
    os.put(ch) 将字符ch输出到ostream os。返回os。
    is.get() 将is的下一个字节作为int返回
    is.putback(ch) 将字符ch放回is。返回is
    is.unget() 将is向后移动一个字节。返回is（向后即退回一个字节）
    is.peek() 将下一个字节作为int返回，但不从流中删除他。
    有时候我们需要读取一个字符，才能知道是否准备好处理它。在这种情况下我们需要将字符放回流中，等待就绪后再读取。标准库提供putback() unget() peek()三种函数退回字符。其中peek返回下一元素的副本，但并不从流中删除，也就是说调用peek之后，再调用get会得到一样的结果。unget将流向后退，无论刚读取的是什么字符，将其退回到流中。putback是更特殊的unget函数，但他接受一个参数，此参数必须与最后读取的值相同。
    关于返回int的说明： 如果返回原本的类型及char的话，则有些特殊字符可能无法表示，如EOF标志。因此，返回int的函数将它要返回的函数先转换为unsigned char，然后再将结果提升到int。因此，即使有些字符映射到负值，这些操作返回的int也是正值。

    多字节操作：
    is.get(sink,size,delim) 从流is中读取最多size个字节，保存到sink为起始地址的字符数组中。读取过程直至遇到字符delim或者文件结尾或者读取了size个字符位置。如果遇到了delim，则将其留在输入流中，不存入sink。
    is.getline(sink,size,delim) 与get类似，但是会读取并丢弃delim。
    is.read(sink,size) 读取最多size个字节，存入字符数组sink中。返回is。
    is.gcount() 返回上一个未格式化读取操作从is中读取的字节数。如果上一次操作是退回操作如peek，则返回0。
    os.write(source,size) 将字符数组中的size个字节写入os。
    is.ignore(size,delim) 读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore函数有默认参数，size默认值为1，delim默认值为EOF。

44. 流随机访问
    一般来说，各种流类型都支持对流中数据的随机访问。但在大部分系统中，绑定到cin，cout，cerr，clog的流不支持随机访问。
    为了支持随机访问，IO类型维护一个标记来确定下一个读写操作在哪里进行。它提供了两个函数，一个函数通过将标记seek到一个给定位置来重定位它，另一个函数tell标记的当前位置。seek函数和tell函数关于输入流和输出流的区别在于后缀，输入流函数后缀为g表示get，输出流后缀为p，表示put。

    tellg() tellp() 返回一个输入或输出流中标记的当前位置。
    seekp(pos) seekg(pos) 在一个输入流或输出流中将标记重定位到给定的绝对地址。pos通常是前一个tellg或tellp返回的值。
    seekp(off,from) seekg(off,from)在一个输入或输出流中将标记定位到from之前或之后off个字符，from可以是:beg,偏移量现对于流开始位置；cur，偏移量相对于流当前位置；end，偏移量相对于流结尾位置。例如：is.seekg(-10,iostream::end)，is >> str； 表示将流定位到流结尾的前10个字符的位置。即读取最后10个字符。

45. UNION联合体
    union联合体是一种特殊的数据集，同一时刻，union只能是其数据集中的一种。如union myuni{
        int a;
        float b;
    };任何myuni对象，要么只有一个a成员，要么只有一个b成员。在旧版本中，union不能含有定义了构造函数或拷贝控制成员的类类型，C++11取消了这个限制。但要改变union类型的值是很麻烦的，需要自己显示的调用构造函数或析构函数。如果union含有类类型，且该类型自定义了默认的构造函数和拷贝控制成员，则union会合成对应版本并将其定义为删除的。如果一个类中含有union成员，而且该union含有删除的拷贝控制成员，则该类与之对应的拷贝控制操作也将是删除的。
    管理union成员的方式：一般将union内嵌在另一个类中，且定义一个枚举类型作为判别式，在类中管理union成员。

46. 运行时类型识别
    运行时类型识别（RTTI）主要由两个运算符实现，typeid运算符 dynamic_cast运算符。
    有时候，我们需要使用基类指针执行某个派生类的函数，但该函数不是虚函数。这时，我们可以使用dynamic_cast运算符来将指针换换为我们想要的类型。
    使用方式dynamic_cast<type*>(e) dynamic_cast<type&>(e) 或者dynamic_cast<type&&>(e);
    其中e的类型（指针，引用或者右值）必须与type对应。
    且通常将dynamic_cast用作if判断条件。
    例如parent* p = new children;//p是指向派生类的基类指针，可以转换为指向派生类的派生类指针。
    if(children* c = dynamic_cast<children*>(p))//这种转换p必须指向派生类对象或者空，否则会发生错误
    {
        //访问c
    }else
    {
        //访问p
    }
    也可以将派生类指针转换为基类指针
    children* c = new children;
    if(parent* p = dynamic_cast<parent*>(c))
    {

    }else
    {

    }//p还是指向派生类对象。
    这样做可以在一个操作中同时完成类型转换和条件检查两项任务，且如果转换失败，在if语句外也无法访问转换失败的指针，从而确保是安全的。
    需要注意的是，引用类型与指针类型不同，因为不存在所谓的空引用，即类型转换失败时，转换为指针失败会返回一个空指针，而转换引用时,会将一个引用绑定到空地址上，这样会抛出一个名为bad_cast的异常，该异常定义在头文件typeinfo中，因此，使用引用类型时应该这样写：
    children chil;
    parent& p = chil;
    try{
        children& c = dynamic_cast<children&>(p);
        //访问c
    }catch(bad_cast){
        //访问p
    }

    typeid运算符，typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字。typeid返回的是一个常亮对象的引用。且顶层const通常被忽略(即指针或引用本身是否是常量被忽略，我们只关注指针或引用所指是否是常量)
    当e是引用类型时，typeid(e)返回的是e所引用的类型。而且typeid表达式不会进行数组到指针的隐式转换。
    当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果只有到运行时才会求得。当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。
    例如，如果指针p所指的类型不含有虚函数，则typeid(*p)表示p的静态类型，实际上，这种情况下typeid不会对表达式求值,也就是p不需要指向有效值。而动态类型会在运行时对表达式求值。 