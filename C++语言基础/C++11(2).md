31. 删除的拷贝控制和继承
    就像其他的任何类，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义为删除的。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数。
    如果基类的默认构造函数，拷贝构造函数，拷贝赋值运算符或者析构函数是删除的或者不可访问的，则派生类对应成员是删除的，因为编译器不能使用基类成员来执行派生类对象的基类部分的构造、赋值或者销毁操作。
    如果基类有一个删除的或不可访问的析构函数，则派生类中合成的默认构造函数和拷贝构造函数将是删除的，因为编译器不能销毁派生类对象的基类部分。
    编译器不会合成一个删除掉的移动操作，如果使用=defalut请求一个移动操作时，如果基类的对应操作时删除的或不可访问的，则派生类该函数是删除的，因为派生类对象的基类部分不可移动。同样的，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也是删除的。
    总之，如果需要相应操作的话，最好自己显示定义，需要默认操作时可以使用=default，不需要某操作时，也需要显示使用=delete。不要让编译器干你不知道的事。

32. C++继承构造函数
    C++派生类不会继承默认构造函数，拷贝构造函数，拷贝赋值运算符。但是我们可以通过using语句来“继承”，比如在A的子类B中，可以使用using A::A;来显示继承A的构造函数。（没整明白为什么需要这个特性）

33. 声明模板类型为友元，模板类型别名
    我们可以声明模板的类型参数为友元，如
    temolate<class T> class A{
        friend T;
    };
    例如我们使用某个类来初始化模板时，该来为模板类的友元，但是模板类型参数可能是内置类型，在新标准中，内置类型的友好关系是允许的。
    可以使用using或者typedef来定义模板类型别名。如using StrA = A<string>;

34. 模板默认实参
    新标准中允许为模板函数提供默认实参，如template <class T = string> compare(T& a, t& b);类模板也可以。而且，以前的标准是只允许类模板提供模板实参，函数模板不行。

35. 标准库forward函数
    有时候在参数传递时，我们需要保持实参的类型，新标准中我们可以使用forward函数来完成这一功能。forward定义在头文件utility中，与move不同，forward必须通过显示模板实参来调用，forward返回该显示实参类型的右值引用。即forward<T>的返回类型是T&&，通常情况下我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过引用折叠，forward可以保持给定实参的左值或者右值属性。（因为在函数中，即使参数是一个右值，但是无论在什么时候，变量名永远是一个右值，此时将该变量名作为参数时，实际上是传递了一个左值，因此需要使用forward）比如以下函数：
    template <class T> test(T&& arg)
    {
        call(forward<T>(arg));
        虽然arg是一个右值引用，但在此时arg是一个左值，因为它是一个变量名，但是通过forward可以保证他原有的属性，使用一个右值来调用call。即使arg是一个左值，那么forward也能保持arg的属性不变，例如arg是int类型的左值，此时T推断出的类型是int&，则T& &&仍然是一个左值。
    }

36. 可变参数模板
    可变参数模板是指一个接受可变数目参数的模板函数或模板类，可变数目的参数被称为参数包，即存在模板参数包和函数参数包。定义可变参数的方式是使用省略号...。指出一个模板参数或函数参数表示一个包。例如：
    template<class T,class... args>
    void foo(const T&, const args... rest)
    其中args表示模板参数包，rest则是一个函数参数包。与普通模板一样，编译器通过实参来推断参数包类型，例如foo(5,1.0f,3.14f);则T推断出为int类型，参数包类型为<float,float>，函数参数包为(1.0f, 3.14f)。
    如果我们需要知道包中含有多少个元素，可以使用sizeof...运算符，例如sizeof...(rest)或者sizeof...(Args)，返回一个表示数目的常量表达式。

    可变参数模板函数通常是递归的，因为就算模板参数为空，编译器也可以认为这是一个空的模板参数包，例如上面的代码。例如：
    template<class T>
    ostream& print(ostream& os,const T& t)
    {
        return os<<t;
    }
    template<class T,class... Args>
    ostream& print(ostream& os,const T& t,const Args&... rest)
    {
        os << t << ' ';
        return print(os,rest...);
    }
    第一个版本的print负责种植递归打印初始调用的最后一个实参，如果没有上述版本的话，则当最后print函数只有两个参数的时候，其中一个为ostream，一个用来初始化T,此时编译器会认为该函数包为空函数包，则调用print(os,rest)时，此时rest为空，则调用失败，因为没有能用来拿来初始化T的参数了。
    包扩展，通过在参数包后面加上...来扩展参数包，如上面的rest...就是扩展参数包，也就是将参数包扩展为多个参数，此时扩展规则为默认规则，如果是string(rest)...则按照转换为string的规则扩展该参数包。在参数中的Args& ... rest为按引用方式扩展Args，为print生成参数列表。
    我们可以配合标准库forward函数来实现参数转发。即在可变参数模板函数中调用函数。

37. tuple类型
    tuple类型是类似pair的一种类型，不同的是pair类型有且只有两个成员，而tuple可以有任意数量的成员。
    在希望将一些数据组合起来，但又不想定义数据结构时，就可以用到tuple了，定义在头文件tuple中。
    tuple<T1, T2, T3,...,Tn> t;定义一个tuple类型的对象t，其成员数为n，t的第i个成员类型为Ti。且所有成员执行值初始化。
    tuple<T1, T2, T3,...,Tn> t(v1,v2,v3,...,vn);此构造函数是明确的，即explicit的。
    标准库提供了make_tuple(v1,v2,...,vn)来返回一个tuple，tuple的类型由编译器推断。
    get<i>(t)返回tuple对象t的第i个成员的引用。
    tuple_size<t>::value，该模板使用tuple类型初始化，value表示tuple类型t的成员数量。
    tuple_element<i,T>::type，value表示tuple类型T的第i个成员的类型。

38. 标准库bitset类型
    标准库提供了bitset类型来使位运算更容易。
    bitset<n> a;定义了有n位的bitset每一位都是0.
    bitset<n> a(u);a是unsigned long long 值u的低n位的拷贝。如果n大于unsigned long long的大小，则超出部分置为0.此构造函数是constexptr的。
    bitset<n> a(s, pos, m, zero, one)a是string对象s从位置pos开始的m个字符的拷贝，s智能包含字符zero或者one；如果含有其他任意字符，则抛出异常。字符在a中分别保存为zero和one，pos有默认值为0，m默认值为string::npos，npos表示不存在的位置，一般定义为unsigned npos = -1，可以理解为string的长度。zero默认为0，one默认为1。该构造函数也是explicit的。
    bitset<n> a(cp,pos,m,zero,one)与上面的构造函数基本相同，不同的是cp代表的是一个C风格的字符串。
    string中的下标刚好与bitset相反，string中下标最大的字符用来初始化bitset的最低位。如bitset<5> b("1100")；则b[0]为string的最高位即0.b为00110.
    b.any()，b中是否有被置位的位，被置为代表1.有1则返回true。
    b.all()，b中是否全被置位，若全为1则返回true。
    b.none(),b中是否全为0，如全为0则返回true。
    b.count()，返回b中被置位的位数。
    b.size()，返回b中的位数。即初始化模板时提供的n。
    b.test(pos)，位置pos是否是置位的，是1则返回true。
    b.set(),b.set(pos,v)，将pos位置置为v，v默认为true，如不提供参数，将b中所有位置位。
    b.reset(pos),b.reset()，将pos位置复位（0），如果不提供参数，则将所有位复位。
    b.flip(pos),b.flip()，将pos位置取反，不提供参数的话，对b所有位取反。
    b[pos]，返回位置pos的引用，如果是const的，则返回true或者false。
    b.to_ulong(),b.to_ullong(),b.to_string(zero,one)，将bitset转换为ulong或者ulong long 或者string。其中string的zero默认为0，one默认为1.
    bitset还重载了流输出和输入符，os << b，将b中二进制位打印为字符1或者0，打印到流os中。
    is >> b。从is中读取字符到b，当下一个字符不为0或1时，或者已经读取b.size()时，读取停止。

39. 正则表达式
    正则表达式描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串，将匹配的子串替换或者从某个串中取出符号某个条件的子串。C++使用的是ECMAScript标准的正则表达式。
    普通字符：包括没有显式指定为元字符的所有可打印字符和不可打印字符，包括所有大写和小写字母，所有数字，所有标点符号和一些其他符号
    元字符：
    非打印字符也可以是正则表达式的组成部分。
    需要注意的是，在C++中'\'也是一个特殊字符，因此想要得到与ECMAScript相同的效果，需要使用\\。
    \cx匹配由x指明的控制字符，如\cM匹配一个control-M。x必须是A-z的范围，否则c视为原义的'c'字符。
    \d匹配一个数字字符。
    \D匹配一个非数字字符。
    \w匹配字母、数字、下划线。
    \W匹配非字母、数字、下划线。
    \f匹配一个换页符。
    \n匹配一个换行符。
    \r匹配一个回车符。
    \t匹配一个制表符。
    \v匹配一个垂直制表符。
    \s匹配任何空白字符，包括空格制表符换页符等等，等价[ \f\n\r\t\v]。
    \S匹配任何非空白字符，等价于[^ \f\n\r\t\v]。
    \xn匹配n，其中n为十六进制转义值，十六进制转义值必须为确定的两个数字常。例如\x41，匹配'A'。正则表达式可以使用ASCII编码。
    \un匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。
    非捕获元?:,我们可以使用圆括号括起来一些字符形成一个子表达式，但是会有一个副作用，这个子表达式的匹配结果会被缓存。此时可以使用?:放在第一个选项来显示要求不用缓存。
    \num用来显示指明表达式匹配的缓存,即向后引用，缓存最多可以存储99个，下标从0开始。如匹配连续的三个重复数字(\\d)\\1{2}。\\d用来匹配数字，此时\\1表示该匹配的结果,子表达式的序号为其左括号出现的次序，第一个子表达式就是整个表达式本身，因此\\1才是表示此表达式的结果而不是\\0，{2}表示该结果又出现了两次。不要在[]内使用向后引用。

    特殊字符：
    $，匹配输入字符串的结尾位置，
    ()，标记一个子表达式的开始和结束位置，
    *，匹配前面的子表达式零次或多次。
    +，匹配前面的子表达式一次或多次。
    ？，匹配前面的表达式零次或一次。
    .，匹配除换行符之外的任何单字符。[^\n\r]
    [，标记一个中括号表达式的开始。
    \，将下一个字符标记为特殊字符或原义字符。如\n匹配换行，\(匹配'('
    ^,匹配输入字符串的开始位置，在方括号中使用时，它表示非。
    {，标记限定符表达式的开始。
    |，指明两项之间的选择。

    限定符：
    限定符除了+*?之外还有以下三种：
    {n}，n为非负整数，匹配确定的n次。
    {n,}n为非负整数，匹配至少n次。
    {n,m}n，m都为非负整数，且n<=m，匹配至少n次，至多m次。

    定位符：
    ^和$都是定位符，除此之外，还有两种定位符。
    \b，匹配一个单词边界。单词边界即单词和空格之间的位置。非单词边界是其他任何位置。
    \B,匹配一个非单词边界。

    限定符+和*都是贪婪的，即他们为尽可能的匹配更多的字符。如果需要非贪婪，则可以在后面加上?来实现最小匹配。
    比如<a>c++ is the best language.<\a>如果使用\<.*\>，则会匹配整个字符串。而\<.*?\>只匹配标签<a>和<\a>。

    优先级：
    最高： 转义符\
    较高： (),(?:),(?=),[]
    其次： *,+,?,{n},{n,},{n,m}
    最低: ^,$,\任何元字符，任何字符

40. C++正则表达式库regex
    regex初始化，可以直接使用string类型初始化regex对象，如string pattern("[\d]+"),regex reg(pattern)
    ，还可以用C风格数组的指针初始化，也可以使用迭代器表示字符范围，或者字符指针和表示长度的n，此外regex也可以直接赋值。另外，r.mark_count()，返回r中子表达式的数目。r.flags(),返回r的标志集。
    regex_match函数，将一个字符序列与一个正则表达式匹配。
    regex_search函数，寻找第一个与正则表达式匹配的子序列。
    smatch容器类，用来保存在string中搜索的结果。
    ssub_match用来表示string中匹配的子表达式的结果。
    函数regex_match和函数regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个表达式匹配，则regex_match返回true，如果某个子串匹配，则regex_search返回true。这些函数还定义了重载的版本，
    (seq,m,r,mft)与(seq,r,mft)其中seq表示字符序列，r表示regex对象，m是一个match对象，用来保存匹配结果的相关细节，mft是一个可选的参数值，会影响匹配过程，一般情况下使用默认参数就可以了。

    指定regex对象的选项
    使用方法为构造regex对象时指定参数，regex r(re,f)，re为用来初始化regex对象的string或者字符串，f默认为ECMAScript参数，表示使用ECMA-262指定的语法。其他几种常用的参数：
    icase 匹配过程中忽略大小写。
    nosubs 不保存匹配的子表达式
    optimize 执行速度优于构造速度
    例如regex reg(pattern.begin(),pattern.end(),regex::icase);
    还有几种参数用于改变正则表达式的语法.

    正则表达式可以理解为一门新的语言，实际上，正则表达式是在运行时而非编译时编译的，因此正则表达式的错误可能在编译时才抛出。而且正则表达式的编译时一个非常慢的操作，程序开发时应该要注意避免不必要的开销。
    另外，输入序列类型不同时也需要使用不同的正则类，如在搜索string序列时，使用regex,smatch,ssub_match,sregex_iterator。但在搜索序列为char类型字符串时，对应的类就是，regex,cmatch,csub_match,cregex_iterator。

    regex迭代器
    regex迭代器是一种迭代器适配器，它被绑定到一个输入序列和一个regex对象。
    sregex_iterator it(b,e,r)。遍历迭代器b和e表示的string。调用sregex_search(b,e,r)将it定位到输入中的第一个匹配的位置。
    sregex_iterator end;尾后迭代器。
    除此之外，regex迭代器还支持其他迭代器都支持的操作，如自增操作符，解引用操作符，成员访问操作符。

    smatch操作
    m.ready() 如果已经通过regex_search或者regex_match设置了m，则返回true。
    m.size() 如果匹配失败，返回0，否则返回最近一次匹配的正则表达式中子表达式数目。
    m.empty() 如果size为0，返货true。
    m.prefix() 返回一个ssub_match对象，表示当前匹配之前的序列。
    m.suffix() 返回一个ssub_mtach对象，表示当前匹配之后的部分。
    m.length(n) 第n个匹配的子表达式的大小。
    m.position(n) 第n个子表达式距序列开始的距离。
    m.str() 第n个子表达式匹配的string。
    m[n] 对应第n个子表达式的ssub_match对象。
    m.begin(),m.end() 表示m中sub_match对象的范围的迭代器。
    也就是说smatch对象实际上可以看成是一个ssub_match的容器。