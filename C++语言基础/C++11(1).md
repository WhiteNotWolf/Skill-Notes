1. long long 类型。
    c++11规定的新类型。c++标准规定，int至少和一个short一样大，long long至少和一个long一样大，即32位。 long long一般是64位，具体实现与机器相关。

2. 列表初始化。
    新标准中增加了列表初始化，即使用花括号来初始化。无论是初始化或者为对象赋新值，都可以采用这种形式。
    如  vector<int> a{1,2,3,4};  与vector<int> a = {1,2,3,4};等价。
    初始化时，()与{}含义是不一样的。如vector<int> a(10);定义了一个长度为10的vector，其值由vector定义。vector<int> a{10};定义了一个长度为1的vector，其元素值为10；vector<int> a(10,1);定义了含有10个1的vector。此外还可以使用vector<int> a = {1,2,3}形式，使用列表赋值会用右边的元素替换左边的元素。
    关联容器的定义形式如：map<int,int> a{ {1,2}, {3,4} };
    如果变量定义时没有指定初始值，则变量会被默认初始化，此时变量被赋予了默认值，默认值到底是什么由变量的类型和变量定义的位置确定。
    如果内置类型没有被显示的初始化，则定义与任何函数之外的变量被初始化为0，定义在函数体的变量将不被初始化，没有初始化的内置类型的值是未定义的。类的对象具体行为由类自己定义。大部分类允许无须显式初始化定义对象，此时，对象的初始值由类自己定义，如string对象无须初始化，其初始值为一个空串。

3. 空指针nullptr。
    新标准中加入了特殊的字面值nullptr，它可以被转化成任意其他的指针类型。在新标准下，c+     +程序应该尽量使用Nullptr，同时避免使用null。因为在c++程序中，赋值空指针应该是0，NULL在预处理时，宏替换为0(#define NULL 0)，来给指针赋值，但是NULL是无类型的(在c语言环境下，由于没有重载，所以可以义#define NULL  (void*)(0)来给NULL定义类型，但C++不行,在C++中直接给某类型指针赋一个void指针是非法的，因此c++程序中 NULL单纯表示0。)，但是nullptr是有类型的。
    假如有函数 void fun(void* ), void fun(int ).使用fun(NULL)时会调用int版本，但是nullptr能保证在任何情况下都表示一个空指针,即一定会调用void*版本。

4. constexpr常量表达式。
    在复杂系统中，很难分辨一个初始值是不是常量表达式，C++标准规定，允许将变量声明为constexpr类型，以便由编译器来验证变量是否是一个常量表达式。声明为costexpr的变量一定是一个常量，而且必须用常量表达式初始化。一般来说，如果认为某变量是一个常量表达式，应该将其声明为constexpr类型。
    例如：C++编译时可确定常量表达式的结果，因此可在编译时优化。C++规范在一些地方要求使用常量表达式，如声明数组的维数。但常量表达式不允许包含函数调用或者对象构造。因此下述代码无效：
    int get_five() {return 5;}
    int some_value[get_five() + 7];
    但是将上述函数定义为constexpr int get_five() {return 5;}。则可以满足。
    C++11跟C++14的对constexpr的限制要求不太一样，具体没必要了解太深。

5. 类型别名声明
    传统的方法是使用typedef，新标准可以使用using语句，如using MyInt = int ;
    注意使用类型别名时，如果是复合类型，在声明时将别名替换为原来的类型去理解类型是错误的。
    例如 using str = string*; const str a;与const string* a;是不一样的。

6. 类型指示符auto
    编程时，常常把表达式的值赋给变量，这就需要清楚的知道表达式的值的类型，新标准中引入了auto类型说明符，可以由编译器自己去推断表达式的类型。auto让编译器通过初始值来推断类型，因此使用auto说明符的变量必须要有初始值。auto可以作为函数的返回值类型，此时函数内部所有返回值应该属于同一个类型。auto不能作为函数形参类型。

7. decltype类型说明符
    decltype返回的是其参数的类型。例如decltype(a) b，定义了一个与a同类型的变量b。decltype作用于引用类型时，返回的是一个引用类型。作用于解引用时，返回的也是一个引用类型（一般来说可以通过解引用改变引用对象的值，因此这里应该是引用类型而不是非引用类型）。

8. 类内初始化
    新标准规定，可以为数据成员一个类内初始值。创建对象时，类内初始值用于初始化数据成员，没有初始值的将被默认初始化。定义在类内和函数内的变量将不被初始化(2.列表初始化)。当我们提供类内初始值时，必须使用=或者花括号表示。

9. 范围for语句
    vector<int> a;
    for(auto i : a)此时i的类型是int,a表示的必须是一个序列，一般情况下拥有返回迭代器的begin和end成员。注意如果需要改变a中的元素，应该将i声明为引用类型。

10. 关于容器迭代定义。
    如vector<vector<int>>早期版本需要在外层右尖括号之前打一个空格：vector<vector<int> >。现在取消了这个限制，但是有的编译器可能还是不行。

11. begin与end
    为了兼容数组,使泛型算法可以作用于数组，C++添加了标准库的begin函数，在容器中，begin是成员函数，返回一个迭代器。对于标准库begin函数，应该使用数组作为参数，如int a[5], auto b = begin(a);,返回一个指向数组首元素的非常指针,cbegin(a)返回一个指向首元素的常指针。可以使用这种形式调用泛型算法： i = count(begin(a),end(a),value)。
    关于数组指针与引用的定义：引用不是对象，因此不存在引用的数组，但是有数组的引用，例如 int (&a)[10]；定义了一个a,引用长度为10的数组的对象。同理, int (*a)[10]定义了一个指针a指向长度为10的数组。

12. 关于除法的问题。
    在除法运算中，如果两个数符号相等，则商为正，否则为负。C++11新标准规定商一律向0取整。(-m)/n与m/(-n)都等于-(m/n)。m%(-n)等于m%n，(-m)%n等于-(m%n)。

13. initializer_list形参。
    如果函数的实参数量未知，但是全部实参的类型都相同。则可以使用initializer_list类型的形参。initializer_list表示某种特定类型的值的数组。initializer_list也是一个模板，使用时必须提供模板参数。
    如void test(initializer_list<int> ls);在使用时，实参需要用花括号括起来。如test({1,2,3,4});
    initializer_list也有size,begin,end成员函数，用来遍历元素。
    （一般用在与C程序的接口）

14. 列表初始化返回值。
    C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。比如所，返回vector<string>的函数可以这样返回： return {"hello", "world"}。

15. 尾置返回类型。
    使用尾置返回类型时吗，在本应该写返回类型的地方用auto替代。然后在函数参数列表之后加上->表示尾置返回。
    例如auto test(vector<int> i) -> decltype(i)。
    因为在有些时候，特别是模板编程中，返回类型依赖参数类型，这种时候尾置返回类型就很有用了。

16. =default生成默认构造函数
    新标准中，如果我们需要默认的行为，可以通过在参数列表后面加上=default来要求编译器生成构造函数，=default可以出现在类内部，也可以在外部定义。出现在内部则默认是内联的，外部默认是不内联的。

17. 非成员函数swap
    标准库swap函数可以在常数时间内交换两个容器内容，元素本身并不交换，只交换了内部数据结构。
    新标准中swap函数是通过右值引用来实现的。

18. 容器insert函数和emplace函数。
    insert函数将元素插入到给定的迭代器之前。并返回一个指向第一个插入元素的迭代器。
    emplace_front,emplace,emplace_back分别对应push_front,insert,push_back函数，区别在于，push函数传递一个对象，将其拷贝到指定位置，而emplace函数接受一个参数列表，并在指定位置调用对象的构造函数，构造一个对象。

19. 容器内存分配函数
    c.capacity():不重新分配空间的话，c可以保存多少元素。
    c.reserve(n)： 分配至少能容纳n个元素的空间。
    c.shrink_to_fit():将capacity减少为和size()相同大小。
    只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量，如果需求大于当前容量，reserve分配至少和需求一样大的空间(或者更大)。如果需求小于当前容量，则reserve什么也不做。
    shrink_to_fit函数具体实现可以忽略请求，也就是说可能调用了该函数但是什么也没有做。

20. string转换函数。
    to_string(val),将val转换为string形式，返回该string对象。
    stoi,stod,stol等函数，将string转换为对应格式的数值类型。stoi(string("4396))返回一个4396的int对象。

21. lambda表达式。
    对于一个对象或者表达式，如果可以使用调用运算符(),则称其为可调用的。lamnda表达式可以理解为未命名的内联函数。形式[capture list](parameter list) -> return type { function body }。其中capture list为捕获列表，为lanmda表达式所在函数中定义的局部变量的列表(通常为空)。参数列表和返回类型有时候可以忽略，但必须有捕获列表和函数体。lanmda表达式必须使用尾置返回类型(假如没有显示指定返回类型，此时编译器会自行推断，假如只有一条return语句，则编译器可以推断出类型，如果出了return语句之外有其他任何语句，则编译器推断返回类型为void)，且lanmda表达式不能有默认参数。被捕获的变量，如果是值捕获，则在创建lanmda时拷贝该值，而不是调用时拷贝。如果要捕获引用，比如某些不允许拷贝的对象，只需要在捕获的对象名前加引用符&。需要注意的是，应该确保引用的对象，在lanmda调用时对象时对象是存在的。出于同样的原因，如果需要函数返回一个lanmda表达式，该lanmda表达式不能含有引用捕获。
    
22. 标准库bind函数
    可以将bind函数理解为一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。其一般形式为auto newCallable = bind(callable,arg_list)；其中newCallable是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。当我们调用newCallable时，它会调用callable，并传递给他arg_list中的参数。arg_list可能含有形如_n的名字，其中n为正整数。这些参数表示占位符。占据了传递给newCallable的参数的位置。
    例如auto check1 = bind(check,_1,6,_2);此时表示check1有两个参数，如果调用check1(arg1,arg2).则check1会调用check(arg1,6,arg2)；

23. pair类型。
    pair类型默认进行值初始化，例如pair<int,string> a;则a的int值初始化为0，string初始化为空串。
    make_pair(val1,val2)返回一个pair类型，类型参数由编译器根据val1,val2判断；
    访问pair类型的值，pair.first与pair.second。
    map的value_type为pair<const key_type, mapped_type>;
    对于不含重复关键字的关联容器，insert函数返回一个pair类型pair<map<>::iterator,bool>；
    其中，first成员是一个迭代器，指向具有给定关键字的元素，second成员是一个bool值，用于表明插入是否成功。

24. 无序容器
    用于map和set的操作，也能用于unordered_map和unordered_set；
    无序容器在存储上组织为一个桶。每个桶保存0或n个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，指出应该搜索哪个桶。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。无序容器提供了一些管理桶的函数，以便在某些情况下允许查询桶状态，或者强制容器重组。

    p.bucket_count()返回正在使用的桶的数目。
    p.max_bucket_count()返回容器能容纳的最多的桶的数量。
    p.bucket_size(n)返回第n个桶中元素的数目。
    local_iterator用来访问桶中元素的迭代器类型。
    p.begin(n),p.end(n)，第n个桶的首尾迭代器。
    p.load_factor()返回每个桶的平均元素数量（float）类型。即size/backet_count

    p.max_load_factor(n)，设置试图维护的平均桶大小，p会在需要时添加新的桶，使load_factor <=      n。该函数有重载版本，不加参数时，返回当前max_load_factor,一般默认为1。

    p.rehash(n)，手动重新存储，使得bucket_count >= n,   
        且bucket_count > size/max_load_factor,即大于size和n中的较大值(max_load_factor一般为1).

    p.reserve(n)，重新存储，使得p可以保存n个元素(在满足负载因子小于最大值的情况下)且不必        rehash。

    负载因子(load_factor)：总键值对数/桶的数目。当hash表中的负载因子达到极限(一般是1或者0.75,hashmap解决哈希值冲突的方法是拉链法，当桶中元素的数量太多时，会影响查询性能)，此时hash表会成倍的增加容量，这个过程也叫rehash。
    默认情况下无序容器使用==运算符比较元素。因此自定义类型必须自定义==运算符。一般会间接使用标准库的hash函数，如hash<type>()(struct.val);其中val为自定义类型的内置类型成员。

25. 智能指针
    shared_ptr允许多个指针指向同一个对象
    weak_ptr不允许多个指针指向同一个对象
    weak_ptr，弱引用，指向shared_ptr所管理的对象。
    智能指针能保证，在引用计数为0时能释放内存，假如在某函数内new语句与delete之间的语句发生了异常且未在该函数内被捕获，此时所有的局部变量都会被销毁，且new语句分配的内存不会被释放，且函数外部没有指向该内存的指针，这种情况下没有办法回收该内存。使用智能指针可以避免这种情况发生。
    (默认情况下智能指针只能指向堆内存,因为默认情况下智能指针通过delete来释放对象，而delete只能删除指向堆内存的指针，使用delete删除指向非堆内存对象的指针的结果是未定义的，因此，使用指向非堆内存的指针初始化智能指针结果是未定义的,可以采用shared_ptr<type> a(p,d)形式，其中d为可调用对象，shared_ptr调用d来代替delete.)
    智能指针重载了指针的操作，类似解引用和成员访问符(*和->)。可以通过get成员函数，返回智能指针管理的对象的普通指针。
    shared_ptr有赋值运算符，它会增加运算符右边的对象的引用计数，减少左边运算对象的引用计数。
    最安全的分配动态内存的方法是make_shared<T>(args)，返回一个T类型的动态内存指针。类似于emplace，make_shared用其参数来构造给定类型的对象。
    shared_ptr.unique()函数判断该shared_ptr的引用计数是否为1，是则返回true。
    shared_ptr.use_count()返回与该shared_ptr对象管理同一块内存的shared_ptr数量，可能非常慢，主要用于调试。
    p.reset()函数，p.reset(q),p.reset(q,d)；如果p是唯一指向其对象的智能指针，则调用reset会释放此对象。如果给了可选参数p（内置类型指针），则会令p指向q，如果同时传递了参数d,则会调用d来代替delete。如果没有传递参数，则将p置为空。
    p.get()函数，返回p管理的对象的内置类型指针，一般是为了使用不能使用智能指针的代码，且此代码不能使用delete,且，用get返回的指针去初始化一个新的智能指针是错的。

    unique_ptr:
    unique_ptr独占它所管理的对象。unique_ptr没有类似make_shared的函数，当定义一个           unique_ptr时，需要将其绑定到new返回的指针上，初始化unique_ptr必须采用直接初始化的方式，因为其独占的特性导致它不支持赋值和拷贝操作。
    u.release(),u放弃对对象的控制权，返回其内置类型的指针，并将u置为空。
    u = nullptr。释放u所指向的对象，将u置为空。
    unique_ptr<T,D> a(p,d)。其中T为指针类型，D为删除器类型，p为new返回的指针，d为D类型的可调用对象。其中D和d为可选参数。
    与shared_ptr不同，如果我们需要自定义删除器，则需要在定义unique_ptr时就指明删除器的类型。
    unique_ptr也没有形如reset(q,d)的函数，只有reset(q)。

    weak_ptr:
    弱引用类型，可以指向shared_ptr管理的对象且不会增加shared_ptr的引用计数。当shared_ptr引用计数为0时，即使有weak_ptr还在引用它，该对象依然会被shared_ptr释放。
    weak_ptr<T> w(sp),其中sp为shared_ptr对象。
    w = p,p可以是weak_ptr或者shared_ptr。
    w.reset(),将w置为空。
    w.use_count(),返回与w共享对象的shared_ptr的数目。
    w.expired()，如果与w共享对象的shared_ptr的数目为0，返回true,否则返回false。
    w.lock(),如果expired返回true,lock返回一个空shared_ptr，否则返回一个指向w的对象的shared_ptr。
    weak_ptr可以用于解决循环引用的问题。其次，通常通过shared_ptr来管理数据，weak_ptr来为用户提供访问。例如： if(auto temp = w.lock()){ //通过temp访问} else{ //该对象已经被释放}。

26. 动态数组
    我们可以采用new T[size]的形式动态申请数组，也可以使用类型别名来定义，如：
    using myarray = char[11];
    auto s = new myarray{'h','e','l','l','o',' ','w','o','r','l','d'};
    分配一个数组会得到一个元素类型的指针，即s的类型为char*。注意，s不是数组，只是某个元素类型的指针而已。
    默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。也可以对其进行值初始化，如new string("hello world"),以及上面的s的列表初始化方式，如果初始化数目小于数组元素数目，则剩余元素进行值初始化。如果初始化数目大于数组元素数目，则new失败。动态分配一个空数组是合法的，此时new返回一个合法的空指针，此指针保证与new返回的其他任何指针都不同，类似于尾后迭代器。
    释放动态数组时，需要采用delete [] p的形式，此时不需要提供数组长度，且p必须指向动态数组的首元素。
    shared_ptr不支持动态数组（如果非要使用的话需要提供自己的删除器），但是unique_ptr支持，例如：uniqur_ptr<int[size]> u(new int[size])指向数组的智能指针不支持*和->运算符。此时u[i]表示u所管理的数组的第i个元素(与下标类似从0开始)。

    allocator类：
    一般情况下，将内存分配和对象构造组合到一起可能会导致不必要的浪费。它提供了一种途径，使我们可以内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的，未构造的。
    allocator是一个模板，使用时必须显示提供模板参数指明它可以分配的对象的类型。成员函数：
    假如我们定义 了allocator<T> a；
    a.allocate(n),分配一段原始的未构造的内存，保存n个类型为T的对象，返回首地址指针。
    a.destroy(p)，p为T类型的指针，此函数对p所指向的对象执行析构函数。destroy之后 ，可以在这块内存上构建其他对象，也可以还给os。
    a.deallocate(p,n),释放从p指针开始的n个T类型的对象，p必须是allocate返回的指针，n必须是p创建时的大小，在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy。
    a.construct(p,args)，p为T类型的指针，指向一块原始内存，args传递给类型为T的构造函数，用来在p指向的内存中构造一个对象。

27. 类的拷贝、赋值与析构。

    右值引用：
    为了支持移动操作，新标准引入了一种新的引用类型：右值引用，也就是，必须绑定到右值上的引用。
    我们通过&&来来获得一个右值引用。右值引用最重要的特质是：只能绑定到一个将要销毁的对象，因此我们可以自由的将一个右值引用的资源移动到另一个对象中。对于左值引用来说，我们不能将其绑定到要求转换的表达式，字面值常量或返回右值的表达式，右值引用完全相反，且右值引用不能绑定到一个左值上。一般来说，左值就是赋值号左边的对象，右值就是右边的，但是本质上的区别左值可以取地址而右值不行。
    int i = 777;此时int& left = i是正确的，但是int&& right = i时错误的，因为右值引用不能绑定到左值上。同理int& left = i*4396是错误的，但是int&& right = i*4396是正确的。
    可以使用一个const的左值引用绑定到一个右值上。
    任何表达式都是一个左值，包括右值引用。

    move函数：
    move函数的定义为：
    template<class T>
    typename remove_reference<T>::type&& move(T&& t)
    {
        return static_cast<typename remove_reference<T>::type&&>(t);
    }
    其中typename用于告诉编译器后面的是一个类型而不是一个值。
    remove_referencen模板用于接收去除引用，当使用一个引用类型T&,t&&初始化模板时，其type成员为被引用的类型T，如果使用一个非引用类型初始化，则type成员为T类型。
    static_cast为，任何具有明确定义的转换，只要不具有底层const(底层const指指针或引用所引用的对象时一个const对象)，都可以使用static_cast。
    即我们通过remove_reference获得T去除引用之后的类型，通过static_cast来将t转换为，去除引用之后的类型加上&&的复合类型，也就是右值引用类型。
    这里面最有意思的地方是，T&& t是如何确保能够绑定到任意对象上(左值或右值)，C++中有一种叫做引用折叠的机制，即引用的引用。int& &&实际上类型是int&，类似的int&& &的类型也是int&。除了int&& &&类型为int&&，其余引用的引用都被折叠为int&。也就是说，t为一个右值的时候，T就是t的类型，当t是左值的时候，编译器推断出T为decltype(t)&。
    移动迭代器：一般来说迭代器的解引用操作得到一个左值引用，移动迭代器则返回一个右值引用，可以通过make_move_iterator(ite)来生成迭代器ite对应的移动迭代器版本。

    对于拷贝构造函数的移动构造函数，如test类：
    test{
        public:
        int n;
        //拷贝构造函数
        test(test& t):n(t.n) {}
        //移动构造函数
        test(test&& t) noexcept : n(t.n) {}
    };
    需要注意的是，移动构造函数应该保证移后源对象应该处于一个，可以被安全销毁的状态。比如说假如源对象中含有某指针，则在移动后，源对象不能再指向被移动的资源，应该将其置为nullptr。
    noexcept表明，我们确信该函数执行时不会抛出异常。移动构造函数通常不分配任何资源，因此，移动操作一般不会抛出异常，当编写一个不会抛出异常的函数时，应该将其告诉编译器。因为如果编译器任务函数可能抛出异常的话，会为了处理这些可能性做一些额外的工作。noexcept一般出现在const限定符和引用限定符之后，尾置返回类型之前，成员函数中需要在override、final、=0之前。

    例如在vector中，在调用push_back之后，假如需要重新分配内存，则可能存在两种方式，第一种在新内存中拷贝原有内存中的对象，拷贝完成之后释放原内存中的对象，但是这样显然效率较低。采用移动构造时相对效率就高的多，因为移动构造不需要重新分配内存，它将原内存的控制权交给新对象，释放原有对象对内存的控制权。但是假如在移动构造的过程中，如果已经移动了一部分，剩下一部分没有移动完成时，抛出了异常，此时，旧空间中的对象已经被改变了（已经被移动的那一部分），显然vector需要保证在重新分配内存时，如果出现异常，保证元素不会发生变化。因此如果移动构造函数不是noexcept的，那么vector会使用拷贝构造函数来代替移动构造函数，因为vector需要保证重新分配内存失败时维持原对象不变，如果在拷贝构造函数时出现了异常，很容易满足vector维持自身不变的需求，它只需要释放新申请的内存然后返回。

    引用限定，类似于const限定，可以通过在成员函数后面加上&或者&&来限定调用成员函数的类型。
    比如void test() const{}则该函数可以被const成员调用，但是非const对象也可以调用const版本函数，而const对象只能调用const版本的成员函数。
    引用限定必须加在const限定之后，例如void test() & {}和void test() && {}则通过左值调用时，调用第一个版本，右值调用时调用第二个版本。
    关于特例化，假如某种调用，存在两种可行版本，但是第一种调用存在某种集合上属于第二种调用的关系，比如void test() && {}和void test() const & {}显然通过右值调用时，两种版本都可行，但是，右值引用只能绑定到右值，而const&可以绑定到右值和左值，因此第一种是特例的，此时编译器会选择特例化的版本，如果不存在这种特例化，且上述函数都是可行的，则出现二义性。
    
    移动赋值运算符与移动构造函数类似：
    test& operator=(test&& rhs) noexcept{
        if(this != &rhs){ //检测左侧对象与右侧对象是否是同一对象。
            ...
        }
    }

    可以使用=default来显示的要求默认版本，该函数与编译器自动生成的版本时一样的，例如:
    test() = default;则生成一个默认的构造函数。也可以使用=delete来显示的指明该类不会生成该函数，例如test(const & ) = delete;显示的指明了该类不支持拷贝。
    如果一个类定义了自己的拷贝构造函数，拷贝赋值运算符或析构函数，则编译器不会生成默认的移动构造函数和移动赋值运算符。同样的，如果一个类定义了自己的移动构造函数，移动赋值运算符，则必须定义自己的拷贝构造函数，拷贝赋值运算符，否则这些函数会默认被定义为删除的。只有当一个类没有定义任何类型的拷贝成员，且类的成员都可以移动时，编译器才会生成默认的移动函数。如果一个类有拷贝构造函数但是没有移动构造函数，则其移动操作可以通过拷贝来完成(const test&可以引用test&&)。

    关于类的三五法则：

    需要析构函数的类，几乎可以肯定它也需要拷贝构造函数和赋值运算符，因为需要析构函数的类往往说明了合成的析构函数不能完成对对象的释放，这时候我们认为，合成的拷贝成员也不能完成对成员的拷贝。

    需要拷贝构造函数的类一般也需要赋值运算符，需要赋值运算符的类一般也需要拷贝构造函数。因为当类需要其中某一个函数时，也代表合成版本不能完成对应操作，如果合成的拷贝构造函数不能，则合成的赋值运算符也不行。

    类的析构函数不能被定义为删除的，如果类的析构函数是删除的，则我们无法定义该类的对象，因为该对象无法被释放，但我们可以动态分配该对象并获得其指针，但是无法delete该指针。
    如果类的某个成员的析构函数是删除的或不可访问的（例 private的）则类的合成析构函数被定义为删除的
    如果类的某个成员的拷贝构造函数是删除的或不可访问的（例 private的）则类的合成拷贝函数被定义为删除的
    如果类的某个成员的析构函数是删除的或不可访问的（例 private的）则类的合成拷贝函数被定义为删除的

    如果一个类成员有删除或不可访问的析构函数，则其默认构造函数和拷贝构造函数被定义为删除的。理论上，没有析构函数的类的静态对象定义无法通过编译，所以这种情况应该出现在动态内存分配中，具体为啥就不知道了。

    如果一个类有const或者引用成员，则不能使用合成的拷贝赋值操作，因为const成员和引用成员只能在初始化的时候进行一次赋值。

28. 标准库function类型
    每个lambda表达式有自己的类类型，因此无法使用函数指针来调用lambda表达式。标准库可以通过function来解决这个问题。
    function是一个模板，需要提供显示类型参数，例如function<int(int,int)>它定义了一个function类型，他可以表示接受两个int返回一个int的可调用对象，包括函数指针，lambda表达式，函数对象。但是不能将重载函数的名字村日function类型的对象中。
    本质上function可以看做一个可调用对象，例如function<t> f；可以直接调用f(args)；
    此外也可以用作判断条件，if(f)，f可以转换为bool类型，当f不为空时返回true。

29. explicit显示类型转换运算符
    编译器不会将显示类型转换运算符用于隐式类型转换。
    例如explicit test(int ) {}则该函数必须显示调用，例如test a = 5。如果没有显示类型转换符，则该语句会将5调用test的构造函数，然后调用赋值运算符，但是该函数是explicit，即隐式类型转换无法调用该函数，则int类型的5无法隐式转换为test类型，因此该语句编译将报错。
    但是有一个例外，即表达式呗用作条件，则编译器会将显示的类型转换自动应用于它。

30. override和final
    新标准允许派生类显示的注明它使用的某个成员函数覆盖了它集成的虚函数，即在形参后面，或在const和引用限定后面加上修饰符override。
    类似的，通过加修饰符final，可以阻止该类被继承，当修饰函数时，表明不允许后续的其他类覆盖该函数。
    