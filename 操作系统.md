1. 进程间状态转换。
    >一个进程被创建(调用fork函数时)处于初始的状态，等它分配到它所需要的所有资源后就完成创建，进入就绪状态。就绪状态的进程只要被分配了时间片，就进入了运行状态；运行状态的进程遇见了IO请求或者其他阻塞方式就会进入阻塞状态，从阻塞状态被唤醒又会重新回到就绪状态；处于运行状态的进程如果时间片用完还未完成任务会回到就绪状态。进程如果达到了自然结束点，或者遇见了无法挽回的错误或者被操作系统强行关闭就会进入终止状态。
    * 进程创建，调用fork函数会创建一个进程，调用fork函数后首先会申请一个空白的PCB(进程控制块)，并且向PCB中写入用于控制和管理进程的信息，然后操作系统给它分配运行所需要的资源，资源分配完毕之后就进入了就绪状态，被插入就绪队列。创建进程有两种方式，一种是父进程创建，一种是操作系统创建。
    * 进程终止:进入终止状态的进程不能在执行，操作系统中会保留一个这个进程的状态码供其他进程收集，一旦其他进程完成了对这个进程信息的提取，操作系统就会删除进程，将其PCB清除并返回给系统。
    * 从计算机启动到终端执行程序的过程为：0号进程 -> 1号内核进程 -> 1号用户进程(init进程) -> getty进程 -> shell进程 -> 命令行执行进程。

2. 孤儿进程，僵死进程，守候进程。
    * 孤儿进程：父进程创建子进程后会和子进程一起执行，这个时候如果父进程先完成了任务进入结束状态，那么子进程就成孤儿进程。孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。
    * 僵死进程：如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵死进程。
    * 守护进程：守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。
3. 怎么创建守护进程  
    * 用fork创建子进程，父进程退出，子进程成为孤儿进程被init接管，子进程变为后台进程。
    * 调用setsid()让子进程成为新会话的组长，脱离父进程的会话期。setsid()在调用者是某进程组组长时会失败，但是A已经保证了子进程不会是组长，B之后子进程变成了新会话组的组长。
    * 因为会话组的组长有权限重新打开控制终端，所以这里第二次fork将子进程结束，留着孙进程，孙进程不是会话组的组长所以没有权利再打开控制终端，这样整个程序就与控制终端隔离了
    * 关闭文件描述符：for(int i = 0; i < 65535; ++i){close(i);}；进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。重定向0,1,2标准文件描述符
    * 将工作目录改变到根目录：chdir("/")。重设文件掩码：进程从创建它的父进程那里继承了文件创建掩码。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩码清除：umask(0);
 
3. fork()和vfork()的区别:
    * fork复制父进程的数据段和代码端(写时复制机制？),vfork()共享数据段；
    * fork父子进程执行顺序不确定，vfork保证父进程在vfork等待，子进程退出后才会执行。(exec或exit)


3. 进程间通信方式：
    * 管道(有名和无名):无名管道是类似一种文件但不属于任何的文件系统，只能用在有血缘关系的进程之前通信，有名管道是一种特殊文件，属于文件系统，标识是文件目录，可以用在任意两个进程之间通信。
    * 消息队列：消息队列是一种连接表，存放在内核中由队列ID进行标识，保存的数据有优先级和类型，可以进行随机查询。独立于进程，进程终止消息队列和内容也不会被删除。
    * 信号：用来通知进程某一事件的发生。
    * 信号量：信号量是一种多进程间同步的机制，一般和共享内存一起使用。计数器，信号量的PV操作(原子操作)，P操作：将当前的数值减一（如果数值为0会阻塞），V操作：将数值加一，唤醒因为P操作阻塞的进程。
    * 共享内存：开辟一个进程共享的内存，最快的，需要进行同步，一般和信号量一起使用。
    * socket，跨主机间进程通信，socket(),bind(),listen(),connect(),accept();

4. 线程
    * 有关知识：我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。
    * 线程创建：int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *agr);
    创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。
    pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。
    attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。
    start_routine：线程执行函数的首地址，传入函数指针。
    arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。
    * 获得线程ID：pthread_t pthread_self();调用时，会打印线程ID
    * 等待线程结束：int pthread_join(pthread_t tid, void** retval);tid：创建线程时通过指针得到tid值。retval：指向返回值的指针。
    * 结束线程：pthread_exit(void *retval);

5. 线程间通信：
    * 临界区：使多线程的串行化，访问工作资源或者一串代码，速度快，适合控制数据访问，并发性低。
    * 互斥量：互斥量也就是锁，针对公共资源。
    * 信号量：允许多个线程访问同一资源，但是会限制访问的最大数量。信号量维护的数值。
    * 事件：用来通知线程操作的方式(读写事件)。

6. 线程间同步的方式：
    * 信号量:sem_init(sem)初始化；sem_wait()P操作减1；sem_post()V操作加1；sem_destory(sem)销毁。
    * 互斥锁: pthread_mutex_init(&mutex, NULL);初始化,pthread_mutex_destory()销毁；pthread_mutex_lock()上锁；pthread_mutex_unlock()解锁。
    * 条件变量：某个共享数据到达某个值时，唤醒等待这个共享数据的一个或多个线程。pthrea_cond_init()创建；pthread_cond_destory()销毁；pthread_cond_signal()唤醒一个等待的线程，优先级唤醒；pthread_cond_wait()等待目标变量；

7. 进程和线程的区别.
  >最主要的区别就是他们是不同的操作系统管理方式，每个进程有自己独立的地址空间，相互之间不会干扰，一个进程奔溃后不会的其他进程产生影响，而一个进程的多个线程除了自己的栈和寄存器外，共享地址空间，一个线程的奔溃会导致其他线程的奔溃进而导致整个进程的奔溃。
  >进程是操作系统资源分配的最小单位，线程是CPU调度的最小单位，一个进程可以有多个线程，而一个线程只能属于一个进程。
  >因为线程之间共享地址空间，在创建的时候不用操作系统重新分配资源，而创建一个新的进程需要操作系统重新分配资源，线程创建的开销会小很多；
  >在进行调度的时候，进程调度需要操作系统记录当前进程的CPU状态和设置调度进程的CPU状态，而线程调度只需要记录和设置栈空间、寄存器，线程切换开销小的多。

9. 死锁发生的条件:
    * 互斥条件：进程已经分配到的资源不能被其他进程访问
    * 请求和保持条件:获取一定资源后对其他资源发起请求，但是其他资源已经被分配出去了，会进入阻塞。
    * 不可剥夺条件：已获得的资源不可剥夺。
    * 环路等待条件：进入死锁后，会发生P1等待P2，P2等待P3....Pn等待P1，会陷入死循环。

9. 解决死锁：
    >资源统一分配，破坏请求和保持条件；可剥夺资源，当进程新的资源为得到满足时，释放已有的资源，破坏3,4条件。

10. 互斥锁，读写锁，自旋锁。
    >读写锁，可以有很多读锁，但是只能有一个写锁，写锁会阻塞其他写锁和所有的读锁；自旋锁，同一时刻只能有一个线程访问对象，失败的时候不会进入睡眠，而是在原地自旋，直到锁被释放，如果加锁的时间短暂可以提高效率（睡眠和唤醒也需要时间），如果加锁的时间过长就会浪费CPU资源。

11. 进程（线程）间调度算法。
    * 先来先服务（FCFS）
    * 短作业优先（SJF），选取耗时最短的任务（预计值）；对长作业不利，可能会导致长作业长期不被调度陷入”饥饿“状态
    * 优先级调度，优先级高的先调入内存，非剥夺式优先级调度不能抢占正在执行的进程，剥夺式优先级可以抢占正在执行的进程。静态优先级不可变，动态优先级可变。
    * 高响应比优先调度：对FCFS和SJF的一种综合平衡，响应比R = (等待时间+要求服务时间)/要求服务时间,要求服务时间越短，响应比越高，有利于短作业，解决了饥饿状态。
    * 时间片轮转：选择先来的一个事件，交个它一个时间片，时间片结束后如果事件没有执行完，就把处理机交给下一个就绪事件，然后加入队尾。时间片大小影响很大，时间片过大变成了先来先服务，时间片小会在进程之间频繁的切换，增大开销。
    * 多级反馈队列调度算法：时间片轮转和优先级调度的综合，分为很几个队列，每个队列的优先级依次降低，时间片的大小依次升高，第一优先级最高，时间片最小，对每一个队列做时间片轮转算法，如果在第一个队列的时间片范围内没有完成，就加入到第二队列的队尾，第一队列执行玩之后才能执行第二队列。

12. 操作系统中内存结构
    * 一个可执行的程序在存储(为调入内存)时,分为代码段，数据段，BSS段。调入内存后会分配堆区、栈区等空间。
        代码段:存放程序执行的代码。内容不能修改
        数据段：存放已经初始化的全局变量。静态内存分配。
        BSS段：存放未初始化的全局变量。静态内存分配。

13. Linux虚拟内存
    * 为了防止进程在运行的时候抢占物理内存。

14. 从代码到程序经历来哪些过程
    * 源文件经过预处理得到预处理后的代码，然后经过编译得到汇编代码，经过汇编得到.o文件，最后经过链接器链接得到可执行程序。

15. 协程——一种用户态的轻量级线程
    
    * 协程和线程的最主要的区别在于，线程是抢占式的，由操作系统负责调度，而协程是协作式，的由用户负责调度。进程调度,切换进程上下文,包括分配的内存、数据段、代码段、堆栈段，以及一些表格；线程调度，切换线程的上下文，主要切换堆栈以及各寄存器；协程，轻量级的线程，每个协程都自带一个栈，可以认为一个协程就是一个函数和存放这个函数运行时数据的栈，栈非常小，一般只有几十kb。
    * 只要内存足够，一个线程可以有无数个协程，但某一时刻只能有一个协程在运行，多个线程同一时刻也只有一个协程在运行，多个协程共享该线程分配到的资源。协程持有更小的栈，切换的开销比线程会更小，几乎可以忽略不计。
    * 协程允许我们写同步的代码逻辑，做异步的事情，避免了回调嵌套。使代码的结构更加的清晰。