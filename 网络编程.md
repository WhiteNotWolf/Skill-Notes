### 常用网络编程函数
1. socket
    * 函数模型:```int socket(int domain, int type, int protocol)```
    1. domain

         | 名称 | 含义 |
         | ------ | ------ | 
         | PF_UNIX,PF_LOCAL | 本地通信 | 
         | AF_INET,PF_INET | IPv4 Internet协议 |
         | PF_INET6 | IPv6 Internet协议|
 
    2. type
 
        | 名称 | 含义 |
        | ---------- | ---------- |
        | SOCK_STREAM | TCP连接 |
        | SOCK_DGRAM | UDP连接 |
    
    3. protocol：（一般为0)函数socket()的第3个参数protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，就需要设置这个参数来选择特定的类型。
    * ```int fd = socket(AF_INET,SOCK_STREAM,0);```

2. fcntl：fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性
    * ```int fcntl(int fd,int cmd,long arg);```
    * ```int fcntl(int fd,int cmd,struct flock* lock);```
    1. fd:文件描述符
    2. cmd:对文件描述符进行的操作
        | 命令名 | 含义 |
        | ---------- | ---------- |
        | F_DUPFD | 复制文件描述符 |
        | F_GETFD | 获取文件描述符标志位 |
        | F_SETFD | 设置文件描述符标志位 |
        | F_GETFL | 获取文件状态标志 |
        | F_SETFL | 设置文件状态标志 |
    * ```fcntl(listenfd,F_SETFL,O_NONBLOCK); //设置文件描述符no-block io```

3. setsockopt：设置sock的属性，包括端口的快速回收，取消TIME_WAIT;缓冲区大小；收发时限；优雅的关闭连接
    1. closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket    
        ```bool bReuseaddr=TRUE;```  
        ```setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&bReuseaddr,sizeof(BOOL));```
    2. 如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：  
        ```bool bDontLinger = FALSE;```  
        ```setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&bDontLinger,sizeof(BOOL));```
    3. 在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：  
        ```int nNetTimeout=1000;//1秒```  
        ```setsockopt(s，SOL_S0CKET,SO_SNDTIMEO，(char *)&nNetTimeout,sizeof(int));//发送时限```  
        ```setsockopt(s，SOL_S0CKET,SO_RCVTIMEO，(char *)&nNetTimeout,sizeof(int));//接受时限```
    4. 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：  
        ```int nRecvBuf=32*1024;//设置为32K```  
        ```setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));//接收缓冲区```
        ```int nSendBuf=32*1024;//设置为32K```
        ```setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));//发送缓冲区```
    5. 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能：  
        ```int nZero=0;```  
        ```setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(char *)&nZero,sizeof(nZero));```
    6. 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)：  
        ```int nZero=0;```  
        ```setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(char *)&nZero,sizeof(int));```
    7. 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：  
        ```BOOL bBroadcast=TRUE;```
        ```setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&bBroadcast,sizeof(BOOL));```
    8. 如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket(),以前我们一般采取的措施是"从容关闭"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体应用的要求(即让没发完的数据发送出去后在关闭socket)？  
        ```C++
        struct linger {
        u_short l_onoff;
        u_short l_linger;
        };
        linger m_sLinger;
        m_sLinger.l_onoff=1;//(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留)
        // 如果m_sLinger.l_onoff=0;则功能和第2的作用相同，即强制关闭;
        m_sLinger.l_linger=5;//(容许逗留的时间为5秒)
        setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)&m_sLinger,sizeof(linger));
        ```
4. exit、return、_exit的区别  
    exit和_exit就是用来正常终止一个进程的，主要区别是_exit会立刻进入内核，而exit先执行一些清除工作（包括执行各种终止处理程序，关闭所有标准I／O等，一旦关闭了IO，例如Printf等函数就不会输出任何东西了），然后才进入内核。这两个函数会对父子进程有一定的影响，当用vfork创建子进程时，子进程会先在父进程的地址空间运行（这跟fork不一样），如果子进程调用了exit就会把父进程的IO给关掉。  
    rerurn是一个关键字，只表示返回函数的值，而exit是一个函数，表示进程或者程序的结束。return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出，非0 为非正常退出。