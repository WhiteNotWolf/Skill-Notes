1. 内存泄露的几种情况
    * new和malloc
    * new申请了一块内存之后，指针指向了别的地方。删除的是新的内存，之前申请的内存会发生泄露。
    * 在释放对象数组时在delete中没有使用方括号,方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。
    * 在释放指向对象的指针数组时，只释放了数组，并没有释放数组中指针指向的对象。应该使用一个for循环把数组中的对象释放掉，之后再释放指针；对象数组中存放的是对象，如果在释放的时候只删除了数组的名字，那么只是释放了数组中的第一个对像，并没有把整个数组中的对象释放掉，因此需要释放整个数组。指向对象的数组指针里存放的是指向对象的指针，所以不仅要删除指针数组，还有释放指针指向的内容。
    * 没有将基类的构造函数声明为虚函数，当基类指针指向子类对象的时候，如果基类的析构函数不是虚函数，那么子类的析构函数将不会被调用，子类的资源不能被正确的释放，因此会出现内存泄露。
    * 缺少重载的赋值运算符，在内存可变的类中，比如，t1有一个int变量20,和一个字符数组str[100],t2有一个int变量10,和一个字符数组str[200],执行t1 = t2的时候int变成了10，str会指向一块新的内存[200],那么之前的str[100]并没有被释放掉，就会出现内存泄露。应该在重载的赋值运算符里释放掉原有的内存，然后申请需要的内存。

2. malloc、new、free、delete的区别
    * malloc只是简单的申请内存,new的话申请内存之后还会调用对象的构造函数，所以new可以用来申请一个对象的内存。free只是简单的释放内存，delete先调用析构函数，之后在释放内存。对于基本的数据类型来说，new申请的内存可以用free释放，因为他们没有构造析构函数。
    * malloc和free是c/c++标准库函数，不在编译器的控制权限之内，所以不能调用构造函数和析构函数
    * new和delete是C++运算符，能在编译器的控制下调用构造函数和析构函数  
    * delete和delete[],delete用来释放单个对象的内存，delete用来释放一组对象的内存  
    * free如何知道释放的内存的大小，在内存首地址前面的第16个字节的位置保存了malloc申请的内存的大小   


2. 野指针和野指针的几种情况
    * “野指针”不是NULL指针，是未初始化或未清零的指针，他指向的内存地址不是程序员想要的.会导致程序崩溃
    * 造成野指针的几种情况:指针在创建的时候未进行初始化;在delete之后没有置NULL；指针越界(指针操作超过了变量作用的范围)；

2. 深拷贝和浅拷贝
    * 浅拷贝，原封不动的拷贝，拷贝出来的指针共用一块空间，同一块资源释放多次会导致程序崩溃或者内存泄露；
    * 深拷贝，会复制对象指针指向的内存，会开辟一块新的内存去存放要复制的指针中的内容。

2. 类的成员函数，类里面实现和类外面实现的区别
    * 类的成员函数在类里面实现，表示希望这个函数是内联(inline)函数,类外实现的话则不是，具体还是有编译器类决定是不是真的变成内联。

3. 内联函数(inline)
    * 函数调用：编译过程的最终产品是可执行程序--由一组机器语言指令组成。运行程序时，操作系统将这些指令载入计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环和分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。
    * 内联函数：内联函数提供了另一种选择。在函数定义声明前加inline,编译器在编译的时候将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
    * 内联函数和define的区别：define是文本替代，转换的时候不会考虑转换之后功能是否正常，inline会考虑转换之后的功能是否正常。
    * 当要执行的代码时间很短的时候，建议使用内联函数，当要执行的代码时间很长，节省的时间占比很小，就可以考虑不使用内联函数。

3. 四种类型转换
    * const_cast<>(),将const型变量转换成非const型变量。
    * static_cast<>(),用来强迫隐式转换(不需要用户干预，编译器私下进行的转换，数值和bool的转换，显示转换，需要执行代码的转换,char_to_int)。可以将非const转换为const；基本数据类型之间的转换；还可以实现类之间上下进行转换。上行转换是安全的，下行转换是不安全的(转换不成功的时候不知道)。
    * dynamic_cast<>(),只能用于对象的指针或引用之间向上或向下转换，它会检查返回的对象是不是一个有效的完整对象，如果不是的话会返回NULL,比如你申请了一个基类的指针```base* b1 = new derive;```指向派生类，然后声明一个派生类指针```derive* d1 = dynamic_cast<derive>(b1)```,这样的执行结果是成功的，但是如果你申请了一个基类的指针base* b2 = new base;指向的是基类，你调用```derive* d2 = dynamic_cast<derive>(b2)```去获取派生类的指针的时候，就会出现错误，返回值会是NULL.
    * reinterpret_cast<>(),可以实现不同类型的指针类型之间进行转换，但是它的转换过程和结果由编译器决定，所以是不可移植的。

4. C和C++的区别
    * C和C++最主要的区别就是，C是面向过程的编程，而C++是面向对象的编程语言。C面向过程，修改和调试起来会简单一些，而且既可以对硬件进行编程也可以对软件进行编程，而且具备可移植性，而C++是在C的这些基础上通过继承和多态实现了面向对象的编程，还能够利用模板进行范式化编程。
5. 面向对象的特点:继承、封装与多态  
    * 继承：就是子类可以拥有父类的属性和方法，分为public和private继承  
    * 封装：就是把事物的属性和动作隐藏起来，只暴露方法(即函数接口),抽象出类，封装能实现代码功能的分离，使代码更加清晰    
    * 多态：不同的对象，接收相同的消息，产生不同的动作，运行时多态，继承和重写虚函数；编译时多态，函数重载和运算符重载  
5. 构造函数和析构函数
    * 构造时会先调用基类的构造函数构造基类，然后才会调用派生类的构造函数，是通过this指针调用的，所以构造函数中如果调用了虚函数，基类调用就是基类的，父类调用就是父类的。析构的时候先析构派生类，再析构基类。
    * 构造函数声明为私有函数的类，可以被继承，但是不能构建对象（实例化）。  
    * 构造函数不能被声明为虚函数，因为虚函数是通过虚函数指针调用的，而虚函数指针是在构造函数的初始化列表(冒号初始化)中初始化的，这样会导致一个死循环，虚函数指针要初始化才能调用构造函数，但构造函数才能初始化虚函数指针。理论:构造函数是为了构建对象的，而调用虚函数需要知道对象的类型，要知道调用的是子类的虚函数还是父类的虚函数，而在构造的时候对象类型还没有确定，不能知道调用哪个虚函数，所以是错误的。  
    * 析构函数推荐声明为虚函数，如果用基类的指针指向派生类构建一个对象，如果析构函数不是虚函数的话，这个时候只会调用基类的析构函数去析构对象，而构造函数却是调用的派生类的构造函数，所以会导致对象释放的不干净,导致内存泄漏。
6. 空类  
    * sizeof(空类对象) = 1,因为类在实例化的时候都会获得一个独一无二的地址，为了达到这个目的,编译器会给空类隐含的增加一个字节(char),这样就可以使空类在实例化之后的内存中得到独一无二的地址。  
    * 一个对象的大小：vptr（指向虚函数表的指针）+ 所有非静态数据成员的大小 + 字节对齐大小  
    * 空类在“泛型编程”中，空类（空结构）的用处非常广，我们利用类型（通常是空类），来区别对待不同类对象的属性。通过使用函数重载的方法，在参数中加入一个空类来作为区分不同的函数的方法，编译的时候直接选择，而不是在运行的时候选择，是非常提高效率的。  
7. 空数组  
    * 空数组在结构体中不占空间，空数组名是一个指针（但是不占空间），它指向一个位置，在结构体中，指针指向前面一个成员结束后的第一个空间，所以可以用来设计缓冲区  
    * 非结构体中，指针指向前一个对象的地址的下一个字节  
    * 使用空数组可以给结构体加缓冲区，有三种方式给一个结构体加缓冲区：固定长度的buff数组；指向堆上的buff指针动态数组；还有空数组，利用空数组在结构体中指向前面一个成员结束后的第一个空间这一特性,在buffer_len中分配你想要的缓冲区大小    
        ```C++
        struct  T
        {
            int a;
            int b;
            char buffer[0];
        }; 
            struct T* p=(T*)malloc(sizeof(T) +buffer_len);
        ```  
8. 重载和重写
    * 重载是指函数名相同，参数表不同（返回值必须相同）
    * 重写是函数名和参数表都相同，一般发生在继承中，子类重写父类的函数  
9. sizeof  
    * sizeof()不是一个函数，而是一个关键字/操作符，或者说是一种宏，在编译的时候会被替换成相应的数字,所以sizeof(i++),i++是不可能会执被执行的。在栈上定义的数组必须有大小，堆上的数组大小是可变的。 
    * sizeof(void)会报错，sizeof 后面必须是一个明确的类型  
10. 字节长度和机器位数有关的数据类型  
    * 指针:32位4字节，64位8字节  
    * long:32位4字节,64位8字节  
11. const 
    * ```const int a;``` &a 返回的类型是const int*  
    * ```C++
        void print(const int& a){
            std::cout<<a<<std::endl;
        }
        int a = 10;
        const int& b = a;
        int& c = a;
        print(a);
        print(b);
        print(c);
        print(10);   //const int& 可以传右值
      ```    
12. 引用 
    * 不能返回局部变量的引用和new 空间的引用 
    * ```const int &a;```常引用，想要用引用提高程序效率，又想保护传递给函数的数据的时候，可以使用常引用做为参数；如果传递的是一个对象，且数据比较大时，调用构造函数十分耗时，可以考虑使用引用。 

13. 指针和引用的区别  
    * 指针可以为空，引用不能为空  
    
13. 结构体和联合体
    * 结构体的变量都有自己的空间，而联合体的所有变量共用空间
    * 联合体中变量赋值会改变其他变量的值，结构体不会，因此可以联合体来判断机器的大小端,还可以通过把int转换成char的方式来判断大小端(即高字节转换成低字节)    
    ```C++
    //大端，高字节保存在低地址，小端，高字节保存在高地址
    union Un{
        int a;
        char s;
    };
        Un un;
    un.a = 1;
    if(un.s == 1){
        cout<<"小端"<<endl;
    } 
    else{
        cout<<"大端"<<endl;
    }
    ```  
14. struct和class区别
    * struct默认成员全部都是public，class默认是private  
    * struct的继承默认是public，class的继承默认是private  

15. time+程序名，可以查看程序的运行时间和cpu占用率    