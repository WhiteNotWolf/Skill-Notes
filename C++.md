1. 内存泄露的几种情况
    * new和malloc
    * new申请了一块内存之后，指针指向了别的地方。删除的是新的内存，之前申请的内存会发生泄露。
    * 在释放对象数组时在delete中没有使用方括号,方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。
    * 在释放指向对象的指针数组时，只释放了数组，并没有释放数组中指针指向的对象。应该使用一个for循环把数组中的对象释放掉，之后再释放指针；对象数组中存放的是对象，如果在释放的时候只删除了数组的名字，那么只是释放了数组中的第一个对像，并没有把整个数组中的对象释放掉，因此需要释放整个数组。指向对象的数组指针里存放的是指向对象的指针，所以不仅要删除指针数组，还有释放指针指向的内容。
    * 没有将基类的构造函数声明为虚函数，当基类指针指向子类对象的时候，如果基类的析构函数不是虚函数，那么子类的析构函数将不会被调用，子类的资源不能被正确的释放，因此会出现内存泄露。
    * 缺少重载的赋值运算符，在内存可变的类中，比如，t1有一个int变量20,和一个字符数组str[100],t2有一个int变量10,和一个字符数组str[200],执行t1 = t2的时候int变成了10，str会指向一块新的内存[200],那么之前的str[100]并没有被释放掉，就会出现内存泄露。应该在重载的赋值运算符里释放掉原有的内存，然后申请需要的内存。

2. malloc、new、free、delete的区别
    >malloc只是简单的申请内存,new的话申请内存之后还会调用对象的构造函数，所以new可以用来申请一个对象的内存。free只是简单的释放内存，delete先调用析构函数，之后在释放内存。对于基本的数据类型来说，new申请的内存可以用free释放，因为他们没有构造析构函数。

2. 野指针和野指针的几种情况
    >“野指针”不是NULL指针，是未初始化或未清零的指针，他指向的内存地址不是程序员想要的.会导致程序崩溃
    >造成野指针的几种情况:指针在创建的时候未进行初始化;在delete之后没有置NULL；指针越界(指针操作超过了变量作用的范围)；

2. 深拷贝和浅拷贝
    >浅拷贝，原封不动的拷贝，拷贝出来的指针共用一块空间，同一块资源释放多次会导致程序崩溃或者内存泄露；深拷贝，会复制对象指针指向的内存，会开辟一块新的内存去存放要复制的指针中的内容。

2. 类的成员函数，类里面实现和类外面实现的区别
    >类的成员函数在类里面实现，表示希望这个函数是内联(inline)函数,类外实现的话则不是，具体还是有编译器类决定是不是真的变成内联。

3. 内联函数(inline)
    * 函数调用：编译过程的最终产品是可执行程序--由一组机器语言指令组成。运行程序时，操作系统将这些指令载入计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环和分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。
    * 内联函数：内联函数提供了另一种选择。在函数定义声明前加inline,编译器在编译的时候将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。
    * 内联函数和define的区别：define是文本替代，转换的时候不会考虑转换之后功能是否正常，inline会考虑转换之后的功能是否正常。
    * 当要执行的代码时间很短的时候，建议使用内联函数，当要执行的代码时间很长，节省的时间占比很小，就可以考虑不使用内联函数。

3. 四种类型转换
    * const_cast<>(),将const型变量转换成非const型变量。
    * static_cast<>(),用来强迫隐式转换(不需要用户干预，编译器私下进行的转换，数值和bool的转换，显示转换，需要执行代码的转换,char_to_int)。可以将非const转换为const；基本数据类型之间的转换；还可以实现类之间上下进行转换。上行转换是安全的，下行转换是不安全的(转换不成功的时候不知道)。
    * dynamic_cast<>(),只能用于对象的指针或引用之间向上或向下转换，它会检查返回的对象是不是一个有效的完整对象，如果不是的话会返回NULL,比如你申请了一个基类的指针```base* b1 = new derive;```指向派生类，然后声明一个派生类指针```derive* d1 = dynamic_cast<derive>(b1)```,这样的执行结果是成功的，但是如果你申请了一个基类的指针base* b2 = new base;指向的是基类，你调用```derive* d2 = dynamic_cast<derive>(b2)```去获取派生类的指针的时候，就会出现错误，返回值会是NULL.
    * reinterpret_cast<>(),可以实现不同类型的指针类型之间进行转换，但是它的转换过程和结果由编译器决定，所以是不可移植的。

4. C和C++的区别
    >C和C++最主要的区别就是，C是面向过程的编程，而C++是面向对象的编程语言。C面向过程，修改和调试起来会简单一些，而且既可以对硬件进行编程也可以对软件进行编程，而且具备可移植性，而C++是在C的这些基础上通过继承和多态实现了面向对象的编程，还能够利用模板进行范式化编程。

5. C++的多态
    
    * C++的多态性用一句话概括：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来
    调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。
    * 用virtual关键字声明的函数叫做虚函数，虚函数是类的成员函数，存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的指针，叫做虚函数指针，虚函数表在编译时生成的，虚函数指针则是在构造函数中初始化的，在构造函数执行时，执行函数体之前进行初始化。
    * 多态分为类的多态和函数的多态，类的多态是通过虚函数和延迟绑定来实现的，而函数的多态是通过函数的重载和模板的早绑定来实现的。
    * 编译时多态和运行时多态，编译时多态指的是编译的时候就已经确定了对象执行的函数，运行时多态指的是要等到运行时才知道调用的是哪一个函数。运行时多态是通过虚函数实现的。基类通过虚函数机制可以调用派生类的函数。
    * 纯虚函数是指在虚函数后面再加上 =0 来实现的```virtual void fun() = 0;```，必须在子类中实现这个函数，即现有名称没有内容，在派生类中实现内容。抽象类指的是至少包含一个纯虚函数的类。

6. 虚函数的实现。
    
    * 虚函数是通过虚函数表来实现的，每一个含有虚函数的类都会有一个虚函数表，存放着该类所有虚函数对应的虚函数指针，类的对象就是通过这些虚函数指针去调用对应的虚函数的。
    * 虚函数表的构造，基类直接构造，派生类会继承基类的虚函数表，先拷贝基类的虚函数表，替换已经重写的虚函数指针，把自己新加的虚函数指针添加进去。

7. C++的内存基本上分为5个区：堆、栈、全局和静态存储区、常量存储区、代码区

    * 堆区：动态分配的内存区域，比如new，这里面的内存需要我们手动释放，不然的话会造成内存泄露。程序结束之后，操作系统会回收。内存分配由低地址到高地址。
    * 栈区：栈区中存放的是一些局部变量，函数参数，函数的返回地址和返回值这些东西，它的内存是由编译器分配和释放的。内存分配地址由高地址到低地址。
    * 全局和静态存储区：里面存放的是全局变量和静态变量。
    * 常量存储区：里面存放的是常量，不允许修改，是只读的，（当然可以通过一些不正当的手段修改）
    * 代码区：存放代码，不允许修改。

8. 一个在运行的C编译程序

    * 代码区、初始化数据区（data段）、未初始化数据区（BSS）、堆区、栈区。
    * 代码区：保存的是一些汇编指令，根据程序设计的流程依次执行，对于顺序指令，只会执行一次（每个进程），如果需要反复执行（循环），需要使用跳转指令，如果进行递归，则需要借助栈来实现；全局初始化数据区/静态数据区（data段）:只初始化一次；未初始化数据区(BSS)：在运行时改变其值；堆区: 用于动态内存的分配；栈区:由编译器自动分配和释放，存放函数的参数值，局部变量，返回地址，返回值等。

9. sizeof内存对齐问题  
    * sizeof是运算符不是函数，在计算空间大小的时候如果是类型名必须加括号，如果是变量名可以不加。
    * 有关内存对齐方面，32位系统4字节对齐，64位系统8字节对齐

        