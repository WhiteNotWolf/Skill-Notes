### STL
1. vertor
    >vector维护的是一块连续的空间，最开始的时候会申请一块空间大小，当向里面插入数据超过了预设空间的大小会重新申请二倍大小的空间，然后把原来的内容拷贝过去，删除中间元素时会依次把后面的元素向前移动一位。中间插入也是一样，会后移。插入删除都会引起迭代器的失效。
2. deque双端队列
    >顺序存储，通过map将多个缓存区连接起来，前后插入都是O(1)，中间插入和删除都会造成迭代器失效。
3. queue和stack，优先队列
    >queue和stack,底层实现deque;priority_queue底层实现是堆(大小根堆),默认使用大根堆；
4. pair,map,set
    >pair是一种简单的关联类型pair<T,T>，不属于容器，是一种键值对；map里面存储的是pair对象，map和set底层实现红黑树，会自动排序,访问log(n),map中存放的是键值对映射，set中存放的是元素，set中重复的元素会自动覆盖，set中的元素只能插入和删除不能修改，map键不能修改，值可以修改。用下标访问map时，如果下标不存在，会在map中生成一个新的键值对，使map变大。set中可以放入pair关联类型实现一个key有多个value;
5. hash_map,hash_table
    >底层实现hash_table(数组和链表)，不会自动排序，访问o(1)，使用方法和map、set一样。

6. 解决hash冲突的方法：
    * 线性寻址：取模之后，如果当前位置已经保存的有元素了，就保存在后一位。
    * 再散列法：建立多个hash函数，发生冲突时使用下一个hash函数，直到没有冲突为止。
    * 拉链法：冲突位置建立一个链表，将冲突的元素插入到链表尾部。
    * 建立公共溢出区：将hash表分为基本表和溢出表，将与基本表冲突的元素加入的溢出表中。
 
7. STL中的排序
    * sort,sort中的快排不是普通的快排，对普通的快排进行了优化，还结合了插入排序和堆排序，根据不同的数量级和不同的情况，会自动的选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序。普通的快排是选取数组中第一个元素为基准，而sort中会选取头部，尾部，和中间，取三者的中间值作为基准，进行了这样的优化。
    * qsort,要求自己提供比较函数，底层实现就是快排。
    * stable_sort,稳定的排序,sort是不稳定的。
    * partial_sort,用于对元素中一个区域范围进行排序，会复制这个区域内的元素到一个新的容器中，然后进行排序。
    * list::sort,是list自带的排序，对于list来说，他比一般的排序算法要快，因为它对列表进行了优化，是交换指针，不是复制对象。
    * set也可以用来对集合进行排序，要求数组中没有重复的元素。

7. 一致性hash问题
    * 一致性hash被提出了用来解决分布式cash问题，把0-2^32头尾相连成一个圆上，然后把服务器分配到圆上，均匀分配，每当一个请求过来，按ip地址或者其他的一些标识条件对hash值取模，落在圆上，然后顺时针找到第一个服务器，分配服务器去处理请求。添加服务器时只会影响到添加点逆时针到上一个服务器这一段距离内的数据，容错性和可扩展性增强。如果一个服务器出现了故障，只会影响到当前服务器逆时针到上一个服务器内访问的数据。

7. multimap和multiset
    >multimap允许出现重复的键，multiset也允许出现重复的值。

7. 迭代器失效
    * 顺序型迭代器失效(vector,deque)，当用迭代器删除一个元素或者添加一个元素之后，位置发生改变了的迭代器全部都会失效。删除一个元素时,该元素和该元素后面的迭代器全部都会失效，vector和deque的删除函数都会返回下一个迭代器，可以删除之后立刻得到下一个元素的迭代器。vector插入操作会导致插入元素后面的迭代器失效，如果重新分配了空间，该元祖的所有迭代器都会失效。deque的插入操作会使迭代器、指针、引用全部失效，首尾插入只会导致迭代器失效。deque删除首尾不会导致其他迭代器失效，删除中间元素会导致所有迭代器失效。
    * 关联型迭代器失效，对于关联容器(如map, set,multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这里主要解释一下erase(it++)的执行过程：这句话分三步走，先把iter传值到erase里面，然后iter自增，然后执行erase,所以iter在失效前已经自增了。 map是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。

8. STL线程安全问题
    >多个线程同时读一个容器没问题，多个线程同时写不同容器也没问题，多个线程同时写一个容器就会有迭代器失效的情况，因此只要有迭代器失效的情况STL中容器就不是线程安全的，需要通过加锁来保证线程安全。

### 排序算法
1. 冒泡排序
    >时间复杂度O(n^2),空间复杂度O(1),稳定的排序(稳定不稳定是针对相同元素的相对位置而言，相对位置改变了就是不稳定的)，从前向后扫描，把大(小)元素不断的向后移动。
2. 选择排序
    >时间复杂度o(n^2),空间复杂读O(1),稳定性取决判断条件(是>还是>=)，从当前的位置向后找，找到最大或最小的元素和当前位置的元素交换。
3. 插入排序
    >时间复杂度O(n^2),空间复杂度O(1),稳定的排序,从当前位置向前扫描，插入到一个比它大或者比它小的元素的后面。 
4. 希尔排序
    >时间复杂度O(n^1.3)首个突破O(n^2)的排序算法,空间复杂度O(1),不稳定,n个元素，先分成n/2个序列，对每个序列进行插入排序，然后分成n/3个序列，重复操作，知道最后成为一个序列.
5. 归并排序
    >时间复杂度O(nlogn),空间复杂度O(n),稳定,利用分治的方法不断的二分，直到只剩两个元素，然后两个元素比较完大小之后再返回，相邻两个分组之间依次排序。
6. 快速排序
    >时间复杂读O(nlogn),空间复杂度O(nlogn)就地排序是O(1),递归要保存数据O(nlogn),不稳定，每次选择一个基准(一般是第一个元素)，每次从前向后找到一个比基准大的，从后向前找到一个比基准小的，交换他们，直到前后位置相遇，这个时候相遇位置前面的都比赛基准小，后面的都比基准大，然后把基准放到中间，再对两边进行遍历，一层层递归下去。
7. 堆排序
    >事件复杂度O(nlogn),空间复杂度O(1),不稳定，建立大根堆或者小根堆(直接数组建立就行，树的非叶子节点=所有节点/2-1)，然后非叶子节点的尾部开始调整堆，使之变成大根堆或者小根堆，最大或最小的值保存在数组首部，每次把数组首部的元素交换到数组尾部，对数组首部做一个维护。建堆的时间复杂度为O(n),每一个对堆进行维护的时候是O(logn),要维护n次，所以是O(nlogn).
8. 计数排序
    >时间复杂度O(n+k),空间复杂度O(k),稳定,需要额外的K大小的空间，用空间换时间，每次遍历一次把数据保存到K空间里，即对应的位置++,然后再从头到尾遍历一遍K空间，把依次把K空间里的元素插回原数组中。
9. 桶排序
    >时间复杂度O(n+k),空间复杂度O(n+k),稳定，典型的空间换时间，把分几个桶，每个桶一个范围，把在这个范围内的数据放进这个桶里，用链表保存，依次插入。然后遍历所有的桶，把数据从中依次取出来，放回原数组。
10. 基数排序
    >时间复杂度O(n*k),空间复杂度O(n+k),稳定，桶排序+计数排序，初始化所有数据位数相同，先让所有的数据按个位数排序（保存在桶里，排序用计数排序），排序完成后的数据是按个位排序好的，然后对十位排序，百位排序，直到最高位，这样其实是每一次排一点点，直到最后得到正确的顺序

